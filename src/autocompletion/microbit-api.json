{
    "audio": [],
    "random": [
        {
            "acResult": "getrandbits",
            "type": [
                "function"
            ],
            "documentation": "Generate an integer with ``n`` random bits.\n\nExample: ``random.getrandbits(1)``\n\n:param n: A value between 1-30 (inclusive).",
            "version": 0,
            "params": [
                {
                    "name": "n"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "k",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "seed",
            "type": [
                "function"
            ],
            "documentation": "Initialize the random number generator.\n\nExample: ``random.seed(0)``\n\n:param n: The integer seed\n\nThis will give you reproducibly deterministic randomness from a given starting\nstate (``n``).",
            "version": 0,
            "params": [
                {
                    "name": "n"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "a",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "version",
                        "defaultValue": "2",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "randint",
            "type": [
                "function"
            ],
            "documentation": "Choose a random integer between ``a`` and ``b`` inclusive.\n\nExample: ``random.randint(0, 9)``\n\n:param a: Start value for the range (inclusive)\n:param b: End value for the range (inclusive)\n\nAlias for ``randrange(a, b + 1)``.",
            "version": 0,
            "params": [
                {
                    "name": "a"
                },
                {
                    "name": "b"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "a",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "b",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "randrange",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Choose a randomly selected integer between zero and up to (but not\nincluding) ``stop``.\n\nExample: ``random.randrange(10)``\n\n:param stop: End value for the range (exclusive)",
            "version": 0,
            "params": [
                {
                    "name": "stop"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "start",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "stop",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "step",
                        "defaultValue": "1",
                        "argType": "None"
                    },
                    {
                        "name": "_int",
                        "defaultValue": "...",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "choice",
            "type": [
                "function"
            ],
            "documentation": "Choose a random element from the non-empty sequence ``seq``.\n\nExample: ``random.choice([Image.HAPPY, Image.SAD])``\n\n:param seq: A sequence.\n\nIf ``seq`` is  empty, raises ``IndexError``.",
            "version": 0,
            "params": [
                {
                    "name": "seq"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "seq",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "random",
            "type": [
                "function"
            ],
            "documentation": "Generate a random floating point number in the range [0.0, 1.0).\n\nExample: ``random.random()``\n\n:return: The random floating point number",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "uniform",
            "type": [
                "function"
            ],
            "documentation": "Return a random floating point number between ``a`` and ``b`` inclusive.\n\nExample: ``random.uniform(0, 9)``\n\n:param a: Start value for the range (inclusive)\n:param b: End value for the range (inclusive)",
            "version": 0,
            "params": [
                {
                    "name": "a"
                },
                {
                    "name": "b"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "a",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "b",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        }
    ],
    "math": [
        {
            "acResult": "acos",
            "type": [
                "function"
            ],
            "documentation": "Calculate the inverse cosine.\n\nExample: ``math.acos(1)``\n\n:param x: A number\n:return: The inverse cosine of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "asin",
            "type": [
                "function"
            ],
            "documentation": "Calculate the inverse sine.\n\nExample: ``math.asin(0)``\n\n:param x: A number\n:return: The inverse sine of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "atan",
            "type": [
                "function"
            ],
            "documentation": "Calculate the inverse tangent.\n\nExample: ``math.atan(0)``\n\n:param x: A number\n:return: The inverse tangent of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "atan2",
            "type": [
                "function"
            ],
            "documentation": "Calculate the principal value of the inverse tangent of ``y/x``.\n\nExample: ``math.atan2(0, -1)``\n\n:param y: A number\n:param x: A number\n:return: The principal value of the inverse tangent of ``y/x``",
            "version": 0,
            "params": [
                {
                    "name": "y"
                },
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "y",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "ceil",
            "type": [
                "function"
            ],
            "documentation": "Round a number towards positive infinity.\n\nExample: ``math.ceil(0.1)``\n\n:param x: A number\n:return: ``x`` rounded towards positive infinity.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "copysign",
            "type": [
                "function"
            ],
            "documentation": "Calculate ``x`` with the sign of ``y``.\n\nExample: ``math.copysign(1, -1)``\n\n:param x: A number\n:param y: The source of the sign for the return value\n:return: ``x`` with the sign of ``y``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "y"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "y",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "cos",
            "type": [
                "function"
            ],
            "documentation": "Calculate the cosine of ``x``.\n\nExample: ``math.cos(0)``\n\n:param x: A number\n:return: The cosine of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "degrees",
            "type": [
                "function"
            ],
            "documentation": "Convert radians to degrees.\n\nExample: ``math.degrees(2 * math.pi)``\n\n:param x: A value in radians\n:return: The value converted to degrees",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "exp",
            "type": [
                "function"
            ],
            "documentation": "Calculate the exponential of ``x``.\n\nExample: ``math.exp(1)``\n\n:param x: A number\n:return: The exponential of ``x``.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "fabs",
            "type": [
                "function"
            ],
            "documentation": "Return the absolute value of ``x``.\n\nExample: ``math.fabs(-0.1)``\n\n:param x: A number\n:return: The absolute value of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "floor",
            "type": [
                "function"
            ],
            "documentation": "Round a number towards negative infinity.\n\nExample: ``math.floor(0.9)``\n\n:param x: A number\n:return: ``x`` rounded towards negative infinity.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "fmod",
            "type": [
                "function"
            ],
            "documentation": "Calculate the remainder of ``x/y``.\n\nExample: ``math.fmod(10, 3)``\n\n:param x: The numerator\n:param y: The denominator",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "y"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "y",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "frexp",
            "type": [
                "function"
            ],
            "documentation": "Decomposes a floating-point number into its mantissa and exponent.\n\nExample: ``mantissa, exponent = math.frexp(2)``\n\nThe returned value is the tuple ``(m, e)`` such that ``x == m * 2**e``\nexactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise\nthe relation ``0.5 <= abs(m) < 1`` holds.\n\n:param x: A floating-point number\n:return: A tuple of length two containing its mantissa then exponent",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "isfinite",
            "type": [
                "function"
            ],
            "documentation": "Check if a value is finite.\n\nExample: ``math.isfinite(float('inf'))``\n\n:param x: A number.\n:return: ``True`` if ``x`` is finite, ``False`` otherwise.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "isinf",
            "type": [
                "function"
            ],
            "documentation": "Check if a value is infinite.\n\nExample: ``math.isinf(float('-inf'))``\n\n:param x: A number.\n:return: ``True`` if ``x`` is infinite, ``False`` otherwise.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "isnan",
            "type": [
                "function"
            ],
            "documentation": "Check if a value is not-a-number (NaN).\n\nExample: ``math.isnan(float('nan'))``\n\n:param x: A number\n:return: ``True`` if ``x`` is not-a-number (NaN), ``False`` otherwise.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "ldexp",
            "type": [
                "function"
            ],
            "documentation": "Calculate ``x * (2**exp)``.\n\nExample: ``math.ldexp(0.5, 2)``\n\n:param x: A number\n:param exp: Integer exponent\n:return: ``x * (2**exp)``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "exp"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "i",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "log",
            "type": [
                "function"
            ],
            "documentation": "Calculate the logarithm of ``x`` to the given base (defaults to natural logorithm).\n\nExample: ``math.log(math.e)``\n\nWith one argument, return the natural logarithm of x (to base e).\n\nWith two arguments, return the logarithm of x to the given base, calculated as ``log(x)/log(base)``.\n\n:param x: A number\n:param base: The base to use\n:return: The natural logarithm of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ]
        },
        {
            "acResult": "modf",
            "type": [
                "function"
            ],
            "documentation": "Calculate the fractional and integral parts of ``x``.\n\nExample: ``fractional, integral = math.modf(1.5)``\n\n:param x: A number\n:return: A tuple of two floats representing the fractional then integral parts of ``x``.\n\nBoth the fractional and integral values have the same sign as ``x``.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "pow",
            "type": [
                "function"
            ],
            "documentation": "Returns ``x`` to the power of ``y``.\n\nExample: ``math.pow(4, 0.5)``\n\n:param x: A number\n:param y: The exponent\n:return: ``x`` to the power of ``y``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "y"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "y",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "radians",
            "type": [
                "function"
            ],
            "documentation": "Convert a degrees to radians.\n\nExample: ``math.radians(360)``\n\n:param x: A value in degrees\n:return: The value converted to radians",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "sin",
            "type": [
                "function"
            ],
            "documentation": "Calculate the sine of ``x``.\n\nExample: ``math.sin(math.pi/2)``\n\n:param x: A number\n:return: The sine of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "sqrt",
            "type": [
                "function"
            ],
            "documentation": "Calculate the square root of ``x``.\n\nExample: ``math.sqrt(4)``\n\n:param x: A number\n:return: The square root of ``x``",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "tan",
            "type": [
                "function"
            ],
            "documentation": "Calculate the tangent of ``x``.\n\nExample: ``math.tan(0)``\n\n:param x: A number\n:return: The tangent of ``x``.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "trunc",
            "type": [
                "function"
            ],
            "documentation": "Round a number towards 0.\n\nExample: ``math.trunc(-0.9)``\n\n:param x: A number\n:return: ``x`` rounded towards zero.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "e",
            "type": [
                "variable"
            ],
            "documentation": "Convert a string or number to a floating point number, if possible.",
            "version": 0
        },
        {
            "acResult": "pi",
            "type": [
                "variable"
            ],
            "documentation": "Convert a string or number to a floating point number, if possible.",
            "version": 0
        }
    ],
    "": [
        {
            "acResult": "_SupportsTrunc",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute '_SupportsTrunc'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsTrunc'\n'._SupportsTrunc' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsTrunc'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._SupportsTrunc' is not a callable object\nNo Python documentation found for '._SupportsTrunc'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsTrunc'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._SupportsTrunc' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '._SupportsTrunc'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "object",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The base class of the class hierarchy.\n\nWhen called, it accepts no arguments and returns a new featureless\ninstance that has no instance attributes and cannot be given any.",
            "version": 0
        },
        {
            "acResult": "staticmethod",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Convert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, ...):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()). Both the class and the instance are ignored, and\nneither is passed implicitly as the first argument to the method.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class staticmethod in \n\n.\b.s\bst\bta\bat\bti\bic\bcm\bme\bet\bth\bho\bod\bd = class staticmethod(object)\n |  staticmethod(function) -> method\n |  \n |  Convert a function to be a static method.\n |  \n |  A static method does not receive an implicit first argument.\n |  To declare a static method, use this idiom:\n |  \n |       class C:\n |           @staticmethod\n |           def f(arg1, arg2, ...):\n |               ...\n |  \n |  It can be called either on the class (e.g. C.f()) or on an instance\n |  (e.g. C().f()). Both the class and the instance are ignored, and\n |  neither is passed implicitly as the first argument to the method.\n |  \n |  Static methods in Python are similar to those found in Java or C++.\n |  For a more advanced concept, see the classmethod builtin.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_g\bge\bet\bt_\b__\b_(self, instance, owner, /)\n |      Return an attribute of instance, which is of type owner.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_f\bfu\bun\bnc\bc_\b__\b_\n |  \n |  _\b__\b_i\bis\bsa\bab\bbs\bst\btr\bra\bac\bct\btm\bme\bet\bth\bho\bod\bd_\b__\b_\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'staticmethod'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.staticmethod' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'staticmethod'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.staticmethod' is not a callable object\n"
        },
        {
            "acResult": "classmethod",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Convert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, ...):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class classmethod in \n\n.\b.c\bcl\bla\bas\bss\bsm\bme\bet\bth\bho\bod\bd = class classmethod(object)\n |  classmethod(function) -> method\n |  \n |  Convert a function to be a class method.\n |  \n |  A class method receives the class as implicit first argument,\n |  just like an instance method receives the instance.\n |  To declare a class method, use this idiom:\n |  \n |    class C:\n |        @classmethod\n |        def f(cls, arg1, arg2, ...):\n |            ...\n |  \n |  It can be called either on the class (e.g. C.f()) or on an instance\n |  (e.g. C().f()).  The instance is ignored except for its class.\n |  If a class method is called for a derived class, the derived class\n |  object is passed as the implied first argument.\n |  \n |  Class methods are different than C++ or Java static methods.\n |  If you want those, see the staticmethod builtin.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_g\bge\bet\bt_\b__\b_(self, instance, owner, /)\n |      Return an attribute of instance, which is of type owner.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_f\bfu\bun\bnc\bc_\b__\b_\n |  \n |  _\b__\b_i\bis\bsa\bab\bbs\bst\btr\bra\bac\bct\btm\bme\bet\bth\bho\bod\bd_\b__\b_\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'classmethod'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.classmethod' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'classmethod'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.classmethod' is not a callable object\n"
        },
        {
            "acResult": "type",
            "type": [
                "type",
                "function"
            ],
            "documentation": "type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class type in \n\n.\b.t\bty\byp\bpe\be = class type(object)\n |  type(object_or_name, bases, dict)\n |  type(object) -> the object's type\n |  type(name, bases, dict) -> a new type\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_c\bca\bal\bll\bl_\b__\b_(self, /, *args, **kwargs)\n |      Call self as a function.\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_d\bdi\bir\br_\b__\b_(self, /)\n |      Specialized __dir__ implementation for types.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_i\bin\bns\bst\bta\ban\bnc\bce\bec\bch\bhe\bec\bck\bk_\b__\b_(self, instance, /)\n |      Check if an object is an instance.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Return memory consumption of the type object.\n |  \n |  _\b__\b_s\bsu\bub\bbc\bcl\bla\bas\bss\bsc\bch\bhe\bec\bck\bk_\b__\b_(self, subclass, /)\n |      Check if a class is a subclass.\n |  \n |  _\b__\b_s\bsu\bub\bbc\bcl\bla\bas\bss\bse\bes\bs_\b__\b_(self, /)\n |      Return a list of immediate subclasses.\n |  \n |  m\bmr\bro\bo(self, /)\n |      Return a type's method resolution order.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  _\b__\b_p\bpr\bre\bep\bpa\bar\bre\be_\b__\b_(...)\n |      __prepare__() -> dict\n |      used to create the namespace for the class statement\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs)\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_a\bab\bbs\bst\btr\bra\bac\bct\btm\bme\bet\bth\bho\bod\bds\bs_\b__\b_\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_t\bte\bex\bxt\bt_\b_s\bsi\big\bgn\bna\bat\btu\bur\bre\be_\b__\b_\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_b\bba\bas\bse\be_\b__\b_ = <class 'object'>\n |      The base class of the class hierarchy.\n |      \n |      When called, it accepts no arguments and returns a new featureless\n |      instance that has no instance attributes and cannot be given any.\n |  \n |  _\b__\b_b\bba\bas\bse\bes\bs_\b__\b_ = (<class 'object'>,)\n |  \n |  _\b__\b_b\bba\bas\bsi\bic\bcs\bsi\biz\bze\be_\b__\b_ = 880\n |  \n |  _\b__\b_d\bdi\bic\bct\bto\bof\bff\bfs\bse\bet\bt_\b__\b_ = 264\n |  \n |  _\b__\b_f\bfl\bla\bag\bgs\bs_\b__\b_ = 2148291584\n |  \n |  _\b__\b_i\bit\bte\bem\bms\bsi\biz\bze\be_\b__\b_ = 40\n |  \n |  _\b__\b_m\bmr\bro\bo_\b__\b_ = (<class 'type'>, <class 'object'>)\n |  \n |  _\b__\b_w\bwe\bea\bak\bkr\bre\bef\bfo\bof\bff\bfs\bse\bet\bt_\b__\b_ = 368\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <class 'type'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.type' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <class 'type'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.type' is not a callable object\n"
        },
        {
            "acResult": "super",
            "type": [
                "type",
                "function"
            ],
            "documentation": "super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class super in \n\n.\b.s\bsu\bup\bpe\ber\br = class super(object)\n |  super() -> same as super(__class__, <first argument>)\n |  super(type) -> unbound super object\n |  super(type, obj) -> bound super object; requires isinstance(obj, type)\n |  super(type, type2) -> bound super object; requires issubclass(type2, type)\n |  Typical use to call a cooperative superclass method:\n |  class C(B):\n |      def meth(self, arg):\n |          super().meth(arg)\n |  This works for class methods too:\n |  class C(B):\n |      @classmethod\n |      def cmeth(cls, arg):\n |          super().cmeth(arg)\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_g\bge\bet\bt_\b__\b_(self, instance, owner, /)\n |      Return an attribute of instance, which is of type owner.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_s\bse\bel\blf\bf_\b__\b_\n |      the instance invoking super(); may be None\n |  \n |  _\b__\b_s\bse\bel\blf\bf_\b_c\bcl\bla\bas\bss\bs_\b__\b_\n |      the type of the instance invoking super(); may be None\n |  \n |  _\b__\b_t\bth\bhi\bis\bsc\bcl\bla\bas\bss\bs_\b__\b_\n |      the class invoking super()\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'super'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.super' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'super'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.super' is not a callable object\n"
        },
        {
            "acResult": "int",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class int in \n\n.\b.i\bin\bnt\bt = class int(object)\n |  int([x]) -> integer\n |  int(x, base=10) -> integer\n |  \n |  Convert a number or string to an integer, or return 0 if no arguments\n |  are given.  If x is a number, return x.__int__().  For floating point\n |  numbers, this truncates towards zero.\n |  \n |  If x is not a number or if base is given, then x must be a string,\n |  bytes, or bytearray instance representing an integer literal in the\n |  given base.  The literal can be preceded by '+' or '-' and be surrounded\n |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n |  Base 0 means to interpret the base from the string as an integer literal.\n |  >>> int('0b100', base=0)\n |  4\n |  \n |  Built-in subclasses:\n |      bool\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\bab\bbs\bs_\b__\b_(self, /)\n |      abs(self)\n |  \n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |  \n |  _\b__\b_a\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return self&value.\n |  \n |  _\b__\b_b\bbo\boo\bol\bl_\b__\b_(self, /)\n |      self != 0\n |  \n |  _\b__\b_c\bce\bei\bil\bl_\b__\b_(...)\n |      Ceiling of an Integral returns itself.\n |  \n |  _\b__\b_d\bdi\biv\bvm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return divmod(self, value).\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_f\bfl\blo\boa\bat\bt_\b__\b_(self, /)\n |      float(self)\n |  \n |  _\b__\b_f\bfl\blo\boo\bor\br_\b__\b_(...)\n |      Flooring an Integral returns itself.\n |  \n |  _\b__\b_f\bfl\blo\boo\bor\brd\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return self//value.\n |  \n |  _\b__\b_f\bfo\bor\brm\bma\bat\bt_\b__\b_(self, format_spec, /)\n |      Default object formatter.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\btn\bne\bew\bwa\bar\brg\bgs\bs_\b__\b_(self, /)\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_i\bin\bnd\bde\bex\bx_\b__\b_(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |  \n |  _\b__\b_i\bin\bnt\bt_\b__\b_(self, /)\n |      int(self)\n |  \n |  _\b__\b_i\bin\bnv\bve\ber\brt\bt_\b__\b_(self, /)\n |      ~self\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\bls\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return self<<value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_m\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return self%value.\n |  \n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_n\bne\beg\bg_\b__\b_(self, /)\n |      -self\n |  \n |  _\b__\b_o\bor\br_\b__\b_(self, value, /)\n |      Return self|value.\n |  \n |  _\b__\b_p\bpo\bos\bs_\b__\b_(self, /)\n |      +self\n |  \n |  _\b__\b_p\bpo\bow\bw_\b__\b_(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |  \n |  _\b__\b_r\bra\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return value+self.\n |  \n |  _\b__\b_r\bra\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return value&self.\n |  \n |  _\b__\b_r\brd\bdi\biv\bvm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return divmod(value, self).\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\brf\bfl\blo\boo\bor\brd\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return value//self.\n |  \n |  _\b__\b_r\brl\bls\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return value<<self.\n |  \n |  _\b__\b_r\brm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return value%self.\n |  \n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |  \n |  _\b__\b_r\bro\bor\br_\b__\b_(self, value, /)\n |      Return value|self.\n |  \n |  _\b__\b_r\bro\bou\bun\bnd\bd_\b__\b_(...)\n |      Rounding an Integral returns itself.\n |      Rounding with an ndigits argument also returns an integer.\n |  \n |  _\b__\b_r\brp\bpo\bow\bw_\b__\b_(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |  \n |  _\b__\b_r\brr\brs\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return value>>self.\n |  \n |  _\b__\b_r\brs\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return self>>value.\n |  \n |  _\b__\b_r\brs\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return value-self.\n |  \n |  _\b__\b_r\brt\btr\bru\bue\bed\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return value/self.\n |  \n |  _\b__\b_r\brx\bxo\bor\br_\b__\b_(self, value, /)\n |      Return value^self.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Returns size in memory, in bytes.\n |  \n |  _\b__\b_s\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return self-value.\n |  \n |  _\b__\b_t\btr\bru\bue\bed\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return self/value.\n |  \n |  _\b__\b_t\btr\bru\bun\bnc\bc_\b__\b_(...)\n |      Truncating an Integral returns itself.\n |  \n |  _\b__\b_x\bxo\bor\br_\b__\b_(self, value, /)\n |      Return self^value.\n |  \n |  a\bas\bs_\b_i\bin\bnt\bte\beg\bge\ber\br_\b_r\bra\bat\bti\bio\bo(self, /)\n |      Return integer ratio.\n |      \n |      Return a pair of integers, whose ratio is exactly equal to the original int\n |      and with a positive denominator.\n |      \n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |  \n |  b\bbi\bit\bt_\b_l\ble\ben\bng\bgt\bth\bh(self, /)\n |      Number of bits necessary to represent self in binary.\n |      \n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |  \n |  c\bco\bon\bnj\bju\bug\bga\bat\bte\be(...)\n |      Returns self, the complex conjugate of any int.\n |  \n |  t\bto\bo_\b_b\bby\byt\bte\bes\bs(self, /, length, byteorder, *, signed=False)\n |      Return an array of bytes representing an integer.\n |      \n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  f\bfr\bro\bom\bm_\b_b\bby\byt\bte\bes\bs(bytes, byteorder, *, signed=False) from builtins.type\n |      Return the integer represented by the given array of bytes.\n |      \n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  d\bde\ben\bno\bom\bmi\bin\bna\bat\bto\bor\br\n |      the denominator of a rational number in lowest terms\n |  \n |  i\bim\bma\bag\bg\n |      the imaginary part of a complex number\n |  \n |  n\bnu\bum\bme\ber\bra\bat\bto\bor\br\n |      the numerator of a rational number in lowest terms\n |  \n |  r\bre\bea\bal\bl\n |      the real part of a complex number\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'int'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.int' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'int'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.int' is not a callable object\n"
        },
        {
            "acResult": "float",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Convert a string or number to a floating point number, if possible.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "x",
                        "defaultValue": "0",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "complex",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a complex number from a real part and an optional imaginary part.\n\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "real",
                        "defaultValue": "0",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "imag",
                        "defaultValue": "0",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "str",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class str in \n\n.\b.s\bst\btr\br = class str(object)\n |  str(object='') -> str\n |  str(bytes_or_buffer[, encoding[, errors]]) -> str\n |  \n |  Create a new string object from the given object. If encoding or\n |  errors is specified, then the object must expose a data buffer\n |  that will be decoded using the given encoding and error handler.\n |  Otherwise, returns the result of object.__str__() (if defined)\n |  or repr(object).\n |  encoding defaults to sys.getdefaultencoding().\n |  errors defaults to 'strict'.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return key in self.\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_f\bfo\bor\brm\bma\bat\bt_\b__\b_(self, format_spec, /)\n |      Return a formatted version of the string as described by format_spec.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |  \n |  _\b__\b_g\bge\bet\btn\bne\bew\bwa\bar\brg\bgs\bs_\b__\b_(...)\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_m\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return self%value.\n |  \n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\brm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return value%self.\n |  \n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Return the size of the string in memory, in bytes.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  c\bca\bap\bpi\bit\bta\bal\bli\biz\bze\be(self, /)\n |      Return a capitalized version of the string.\n |      \n |      More specifically, make the first character have upper case and the rest lower\n |      case.\n |  \n |  c\bca\bas\bse\bef\bfo\bol\bld\bd(self, /)\n |      Return a version of the string suitable for caseless comparisons.\n |  \n |  c\bce\ben\bnt\bte\ber\br(self, width, fillchar=' ', /)\n |      Return a centered string of length width.\n |      \n |      Padding is done using the specified fill character (default is a space).\n |  \n |  c\bco\bou\bun\bnt\bt(...)\n |      S.count(sub[, start[, end]]) -> int\n |      \n |      Return the number of non-overlapping occurrences of substring sub in\n |      string S[start:end].  Optional arguments start and end are\n |      interpreted as in slice notation.\n |  \n |  e\ben\bnc\bco\bod\bde\be(self, /, encoding='utf-8', errors='strict')\n |      Encode the string using the codec registered for encoding.\n |      \n |      encoding\n |        The encoding in which to encode the string.\n |      errors\n |        The error handling scheme to use for encoding errors.\n |        The default is 'strict' meaning that encoding errors raise a\n |        UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n |        'xmlcharrefreplace' as well as any other name registered with\n |        codecs.register_error that can handle UnicodeEncodeErrors.\n |  \n |  e\ben\bnd\bds\bsw\bwi\bit\bth\bh(...)\n |      S.endswith(suffix[, start[, end]]) -> bool\n |      \n |      Return True if S ends with the specified suffix, False otherwise.\n |      With optional start, test S beginning at that position.\n |      With optional end, stop comparing S at that position.\n |      suffix can also be a tuple of strings to try.\n |  \n |  e\bex\bxp\bpa\ban\bnd\bdt\bta\bab\bbs\bs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |      \n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |  \n |  f\bfi\bin\bnd\bd(...)\n |      S.find(sub[, start[, end]]) -> int\n |      \n |      Return the lowest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Return -1 on failure.\n |  \n |  f\bfo\bor\brm\bma\bat\bt(...)\n |      S.format(*args, **kwargs) -> str\n |      \n |      Return a formatted version of S, using substitutions from args and kwargs.\n |      The substitutions are identified by braces ('{' and '}').\n |  \n |  f\bfo\bor\brm\bma\bat\bt_\b_m\bma\bap\bp(...)\n |      S.format_map(mapping) -> str\n |      \n |      Return a formatted version of S, using substitutions from mapping.\n |      The substitutions are identified by braces ('{' and '}').\n |  \n |  i\bin\bnd\bde\bex\bx(...)\n |      S.index(sub[, start[, end]]) -> int\n |      \n |      Return the lowest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Raises ValueError when the substring is not found.\n |  \n |  i\bis\bsa\bal\bln\bnu\bum\bm(self, /)\n |      Return True if the string is an alpha-numeric string, False otherwise.\n |      \n |      A string is alpha-numeric if all characters in the string are alpha-numeric and\n |      there is at least one character in the string.\n |  \n |  i\bis\bsa\bal\blp\bph\bha\ba(self, /)\n |      Return True if the string is an alphabetic string, False otherwise.\n |      \n |      A string is alphabetic if all characters in the string are alphabetic and there\n |      is at least one character in the string.\n |  \n |  i\bis\bsa\bas\bsc\bci\bii\bi(self, /)\n |      Return True if all characters in the string are ASCII, False otherwise.\n |      \n |      ASCII characters have code points in the range U+0000-U+007F.\n |      Empty string is ASCII too.\n |  \n |  i\bis\bsd\bde\bec\bci\bim\bma\bal\bl(self, /)\n |      Return True if the string is a decimal string, False otherwise.\n |      \n |      A string is a decimal string if all characters in the string are decimal and\n |      there is at least one character in the string.\n |  \n |  i\bis\bsd\bdi\big\bgi\bit\bt(self, /)\n |      Return True if the string is a digit string, False otherwise.\n |      \n |      A string is a digit string if all characters in the string are digits and there\n |      is at least one character in the string.\n |  \n |  i\bis\bsi\bid\bde\ben\bnt\bti\bif\bfi\bie\ber\br(self, /)\n |      Return True if the string is a valid Python identifier, False otherwise.\n |      \n |      Call keyword.iskeyword(s) to test whether string s is a reserved identifier,\n |      such as \"def\" or \"class\".\n |  \n |  i\bis\bsl\blo\bow\bwe\ber\br(self, /)\n |      Return True if the string is a lowercase string, False otherwise.\n |      \n |      A string is lowercase if all cased characters in the string are lowercase and\n |      there is at least one cased character in the string.\n |  \n |  i\bis\bsn\bnu\bum\bme\ber\bri\bic\bc(self, /)\n |      Return True if the string is a numeric string, False otherwise.\n |      \n |      A string is numeric if all characters in the string are numeric and there is at\n |      least one character in the string.\n |  \n |  i\bis\bsp\bpr\bri\bin\bnt\bta\bab\bbl\ble\be(self, /)\n |      Return True if the string is printable, False otherwise.\n |      \n |      A string is printable if all of its characters are considered printable in\n |      repr() or if it is empty.\n |  \n |  i\bis\bss\bsp\bpa\bac\bce\be(self, /)\n |      Return True if the string is a whitespace string, False otherwise.\n |      \n |      A string is whitespace if all characters in the string are whitespace and there\n |      is at least one character in the string.\n |  \n |  i\bis\bst\bti\bit\btl\ble\be(self, /)\n |      Return True if the string is a title-cased string, False otherwise.\n |      \n |      In a title-cased string, upper- and title-case characters may only\n |      follow uncased characters and lowercase characters only cased ones.\n |  \n |  i\bis\bsu\bup\bpp\bpe\ber\br(self, /)\n |      Return True if the string is an uppercase string, False otherwise.\n |      \n |      A string is uppercase if all cased characters in the string are uppercase and\n |      there is at least one cased character in the string.\n |  \n |  j\bjo\boi\bin\bn(self, iterable, /)\n |      Concatenate any number of strings.\n |      \n |      The string whose method is called is inserted in between each given string.\n |      The result is returned as a new string.\n |      \n |      Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'\n |  \n |  l\blj\bju\bus\bst\bt(self, width, fillchar=' ', /)\n |      Return a left-justified string of length width.\n |      \n |      Padding is done using the specified fill character (default is a space).\n |  \n |  l\blo\bow\bwe\ber\br(self, /)\n |      Return a copy of the string converted to lowercase.\n |  \n |  l\bls\bst\btr\bri\bip\bp(self, chars=None, /)\n |      Return a copy of the string with leading whitespace removed.\n |      \n |      If chars is given and not None, remove characters in chars instead.\n |  \n |  p\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |      \n |      This will search for the separator in the string.  If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |      \n |      If the separator is not found, returns a 3-tuple containing the original string\n |      and two empty strings.\n |  \n |  r\bre\bep\bpl\bla\bac\bce\be(self, old, new, count=-1, /)\n |      Return a copy with all occurrences of substring old replaced by new.\n |      \n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |      \n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |  \n |  r\brf\bfi\bin\bnd\bd(...)\n |      S.rfind(sub[, start[, end]]) -> int\n |      \n |      Return the highest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Return -1 on failure.\n |  \n |  r\bri\bin\bnd\bde\bex\bx(...)\n |      S.rindex(sub[, start[, end]]) -> int\n |      \n |      Return the highest index in S where substring sub is found,\n |      such that sub is contained within S[start:end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Raises ValueError when the substring is not found.\n |  \n |  r\brj\bju\bus\bst\bt(self, width, fillchar=' ', /)\n |      Return a right-justified string of length width.\n |      \n |      Padding is done using the specified fill character (default is a space).\n |  \n |  r\brp\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the string into three parts using the given separator.\n |      \n |      This will search for the separator in the string, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |      \n |      If the separator is not found, returns a 3-tuple containing two empty strings\n |      and the original string.\n |  \n |  r\brs\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the words in the string, using sep as the delimiter string.\n |      \n |        sep\n |          The delimiter according which to split the string.\n |          None (the default value) means split according to any whitespace,\n |          and discard empty strings from the result.\n |        maxsplit\n |          Maximum number of splits to do.\n |          -1 (the default value) means no limit.\n |      \n |      Splits are done starting at the end of the string and working to the front.\n |  \n |  r\brs\bst\btr\bri\bip\bp(self, chars=None, /)\n |      Return a copy of the string with trailing whitespace removed.\n |      \n |      If chars is given and not None, remove characters in chars instead.\n |  \n |  s\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the words in the string, using sep as the delimiter string.\n |      \n |      sep\n |        The delimiter according which to split the string.\n |        None (the default value) means split according to any whitespace,\n |        and discard empty strings from the result.\n |      maxsplit\n |        Maximum number of splits to do.\n |        -1 (the default value) means no limit.\n |  \n |  s\bsp\bpl\bli\bit\btl\bli\bin\bne\bes\bs(self, /, keepends=False)\n |      Return a list of the lines in the string, breaking at line boundaries.\n |      \n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |  \n |  s\bst\bta\bar\brt\bts\bsw\bwi\bit\bth\bh(...)\n |      S.startswith(prefix[, start[, end]]) -> bool\n |      \n |      Return True if S starts with the specified prefix, False otherwise.\n |      With optional start, test S beginning at that position.\n |      With optional end, stop comparing S at that position.\n |      prefix can also be a tuple of strings to try.\n |  \n |  s\bst\btr\bri\bip\bp(self, chars=None, /)\n |      Return a copy of the string with leading and trailing whitespace removed.\n |      \n |      If chars is given and not None, remove characters in chars instead.\n |  \n |  s\bsw\bwa\bap\bpc\bca\bas\bse\be(self, /)\n |      Convert uppercase characters to lowercase and lowercase characters to uppercase.\n |  \n |  t\bti\bit\btl\ble\be(self, /)\n |      Return a version of the string where each word is titlecased.\n |      \n |      More specifically, words start with uppercased characters and all remaining\n |      cased characters have lower case.\n |  \n |  t\btr\bra\ban\bns\bsl\bla\bat\bte\be(self, table, /)\n |      Replace each character in the string using the given translation table.\n |      \n |        table\n |          Translation table, which must be a mapping of Unicode ordinals to\n |          Unicode ordinals, strings, or None.\n |      \n |      The table must implement lookup/indexing via __getitem__, for instance a\n |      dictionary or list.  If this operation raises LookupError, the character is\n |      left untouched.  Characters mapped to None are deleted.\n |  \n |  u\bup\bpp\bpe\ber\br(self, /)\n |      Return a copy of the string converted to uppercase.\n |  \n |  z\bzf\bfi\bil\bll\bl(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |      \n |      The string is never truncated.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  m\bma\bak\bke\bet\btr\bra\ban\bns\bs(...)\n |      Return a translation table usable for str.translate().\n |      \n |      If there is only one argument, it must be a dictionary mapping Unicode\n |      ordinals (integers) or characters to Unicode ordinals, strings or None.\n |      Character keys will be then converted to ordinals.\n |      If there are two arguments, they must be strings of equal length, and\n |      in the resulting dictionary, each character in x will be mapped to the\n |      character at the same position in y. If there is a third argument, it\n |      must be a string, whose characters will be mapped to None in the result.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'str'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.str' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'str'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.str' is not a callable object\n"
        },
        {
            "acResult": "bytes",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Construct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class bytes in \n\n.\b.b\bby\byt\bte\bes\bs = class bytes(object)\n |  bytes(iterable_of_ints) -> bytes\n |  bytes(string, encoding[, errors]) -> bytes\n |  bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\n |  bytes(int) -> bytes object of size given by the parameter initialized with null bytes\n |  bytes() -> empty bytes object\n |  \n |  Construct an immutable array of bytes from:\n |    - an iterable yielding integers in range(256)\n |    - a text string encoded using the specified encoding\n |    - any object implementing the buffer API.\n |    - an integer\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return key in self.\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |  \n |  _\b__\b_g\bge\bet\btn\bne\bew\bwa\bar\brg\bgs\bs_\b__\b_(...)\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_m\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return self%value.\n |  \n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\brm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return value%self.\n |  \n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  c\bca\bap\bpi\bit\bta\bal\bli\biz\bze\be(...)\n |      B.capitalize() -> copy of B\n |      \n |      Return a copy of B with only its first character capitalized (ASCII)\n |      and the rest lower-cased.\n |  \n |  c\bce\ben\bnt\bte\ber\br(self, width, fillchar=b' ', /)\n |      Return a centered string of length width.\n |      \n |      Padding is done using the specified fill character.\n |  \n |  c\bco\bou\bun\bnt\bt(...)\n |      B.count(sub[, start[, end]]) -> int\n |      \n |      Return the number of non-overlapping occurrences of subsection sub in\n |      bytes B[start:end].  Optional arguments start and end are interpreted\n |      as in slice notation.\n |  \n |  d\bde\bec\bco\bod\bde\be(self, /, encoding='utf-8', errors='strict')\n |      Decode the bytes using the codec registered for encoding.\n |      \n |      encoding\n |        The encoding with which to decode the bytes.\n |      errors\n |        The error handling scheme to use for the handling of decoding errors.\n |        The default is 'strict' meaning that decoding errors raise a\n |        UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n |        as well as any other name registered with codecs.register_error that\n |        can handle UnicodeDecodeErrors.\n |  \n |  e\ben\bnd\bds\bsw\bwi\bit\bth\bh(...)\n |      B.endswith(suffix[, start[, end]]) -> bool\n |      \n |      Return True if B ends with the specified suffix, False otherwise.\n |      With optional start, test B beginning at that position.\n |      With optional end, stop comparing B at that position.\n |      suffix can also be a tuple of bytes to try.\n |  \n |  e\bex\bxp\bpa\ban\bnd\bdt\bta\bab\bbs\bs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |      \n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |  \n |  f\bfi\bin\bnd\bd(...)\n |      B.find(sub[, start[, end]]) -> int\n |      \n |      Return the lowest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Return -1 on failure.\n |  \n |  h\bhe\bex\bx(...)\n |      Create a str of hexadecimal numbers from a bytes object.\n |      \n |        sep\n |          An optional single character or byte to separate hex bytes.\n |        bytes_per_sep\n |          How many bytes between separators.  Positive values count from the\n |          right, negative values count from the left.\n |      \n |      Example:\n |      >>> value = b'\\xb9\\x01\\xef'\n |      >>> value.hex()\n |      'b901ef'\n |      >>> value.hex(':')\n |      'b9:01:ef'\n |      >>> value.hex(':', 2)\n |      'b9:01ef'\n |      >>> value.hex(':', -2)\n |      'b901:ef'\n |  \n |  i\bin\bnd\bde\bex\bx(...)\n |      B.index(sub[, start[, end]]) -> int\n |      \n |      Return the lowest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Raises ValueError when the subsection is not found.\n |  \n |  i\bis\bsa\bal\bln\bnu\bum\bm(...)\n |      B.isalnum() -> bool\n |      \n |      Return True if all characters in B are alphanumeric\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bsa\bal\blp\bph\bha\ba(...)\n |      B.isalpha() -> bool\n |      \n |      Return True if all characters in B are alphabetic\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bsa\bas\bsc\bci\bii\bi(...)\n |      B.isascii() -> bool\n |      \n |      Return True if B is empty or all characters in B are ASCII,\n |      False otherwise.\n |  \n |  i\bis\bsd\bdi\big\bgi\bit\bt(...)\n |      B.isdigit() -> bool\n |      \n |      Return True if all characters in B are digits\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bsl\blo\bow\bwe\ber\br(...)\n |      B.islower() -> bool\n |      \n |      Return True if all cased characters in B are lowercase and there is\n |      at least one cased character in B, False otherwise.\n |  \n |  i\bis\bss\bsp\bpa\bac\bce\be(...)\n |      B.isspace() -> bool\n |      \n |      Return True if all characters in B are whitespace\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bst\bti\bit\btl\ble\be(...)\n |      B.istitle() -> bool\n |      \n |      Return True if B is a titlecased string and there is at least one\n |      character in B, i.e. uppercase characters may only follow uncased\n |      characters and lowercase characters only cased ones. Return False\n |      otherwise.\n |  \n |  i\bis\bsu\bup\bpp\bpe\ber\br(...)\n |      B.isupper() -> bool\n |      \n |      Return True if all cased characters in B are uppercase and there is\n |      at least one cased character in B, False otherwise.\n |  \n |  j\bjo\boi\bin\bn(self, iterable_of_bytes, /)\n |      Concatenate any number of bytes objects.\n |      \n |      The bytes whose method is called is inserted in between each pair.\n |      \n |      The result is returned as a new bytes object.\n |      \n |      Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.\n |  \n |  l\blj\bju\bus\bst\bt(self, width, fillchar=b' ', /)\n |      Return a left-justified string of length width.\n |      \n |      Padding is done using the specified fill character.\n |  \n |  l\blo\bow\bwe\ber\br(...)\n |      B.lower() -> copy of B\n |      \n |      Return a copy of B with all ASCII characters converted to lowercase.\n |  \n |  l\bls\bst\btr\bri\bip\bp(self, bytes=None, /)\n |      Strip leading bytes contained in the argument.\n |      \n |      If the argument is omitted or None, strip leading  ASCII whitespace.\n |  \n |  p\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the bytes into three parts using the given separator.\n |      \n |      This will search for the separator sep in the bytes. If the separator is found,\n |      returns a 3-tuple containing the part before the separator, the separator\n |      itself, and the part after it.\n |      \n |      If the separator is not found, returns a 3-tuple containing the original bytes\n |      object and two empty bytes objects.\n |  \n |  r\bre\bep\bpl\bla\bac\bce\be(self, old, new, count=-1, /)\n |      Return a copy with all occurrences of substring old replaced by new.\n |      \n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |      \n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |  \n |  r\brf\bfi\bin\bnd\bd(...)\n |      B.rfind(sub[, start[, end]]) -> int\n |      \n |      Return the highest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Return -1 on failure.\n |  \n |  r\bri\bin\bnd\bde\bex\bx(...)\n |      B.rindex(sub[, start[, end]]) -> int\n |      \n |      Return the highest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Raise ValueError when the subsection is not found.\n |  \n |  r\brj\bju\bus\bst\bt(self, width, fillchar=b' ', /)\n |      Return a right-justified string of length width.\n |      \n |      Padding is done using the specified fill character.\n |  \n |  r\brp\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the bytes into three parts using the given separator.\n |      \n |      This will search for the separator sep in the bytes, starting at the end. If\n |      the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it.\n |      \n |      If the separator is not found, returns a 3-tuple containing two empty bytes\n |      objects and the original bytes object.\n |  \n |  r\brs\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the sections in the bytes, using sep as the delimiter.\n |      \n |        sep\n |          The delimiter according which to split the bytes.\n |          None (the default value) means split on ASCII whitespace characters\n |          (space, tab, return, newline, formfeed, vertical tab).\n |        maxsplit\n |          Maximum number of splits to do.\n |          -1 (the default value) means no limit.\n |      \n |      Splitting is done starting at the end of the bytes and working to the front.\n |  \n |  r\brs\bst\btr\bri\bip\bp(self, bytes=None, /)\n |      Strip trailing bytes contained in the argument.\n |      \n |      If the argument is omitted or None, strip trailing ASCII whitespace.\n |  \n |  s\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the sections in the bytes, using sep as the delimiter.\n |      \n |      sep\n |        The delimiter according which to split the bytes.\n |        None (the default value) means split on ASCII whitespace characters\n |        (space, tab, return, newline, formfeed, vertical tab).\n |      maxsplit\n |        Maximum number of splits to do.\n |        -1 (the default value) means no limit.\n |  \n |  s\bsp\bpl\bli\bit\btl\bli\bin\bne\bes\bs(self, /, keepends=False)\n |      Return a list of the lines in the bytes, breaking at line boundaries.\n |      \n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |  \n |  s\bst\bta\bar\brt\bts\bsw\bwi\bit\bth\bh(...)\n |      B.startswith(prefix[, start[, end]]) -> bool\n |      \n |      Return True if B starts with the specified prefix, False otherwise.\n |      With optional start, test B beginning at that position.\n |      With optional end, stop comparing B at that position.\n |      prefix can also be a tuple of bytes to try.\n |  \n |  s\bst\btr\bri\bip\bp(self, bytes=None, /)\n |      Strip leading and trailing bytes contained in the argument.\n |      \n |      If the argument is omitted or None, strip leading and trailing ASCII whitespace.\n |  \n |  s\bsw\bwa\bap\bpc\bca\bas\bse\be(...)\n |      B.swapcase() -> copy of B\n |      \n |      Return a copy of B with uppercase ASCII characters converted\n |      to lowercase ASCII and vice versa.\n |  \n |  t\bti\bit\btl\ble\be(...)\n |      B.title() -> copy of B\n |      \n |      Return a titlecased version of B, i.e. ASCII words start with uppercase\n |      characters, all remaining cased characters have lowercase.\n |  \n |  t\btr\bra\ban\bns\bsl\bla\bat\bte\be(self, table, /, delete=b'')\n |      Return a copy with each character mapped by the given translation table.\n |      \n |        table\n |          Translation table, which must be a bytes object of length 256.\n |      \n |      All characters occurring in the optional argument delete are removed.\n |      The remaining characters are mapped through the given translation table.\n |  \n |  u\bup\bpp\bpe\ber\br(...)\n |      B.upper() -> copy of B\n |      \n |      Return a copy of B with all ASCII characters converted to uppercase.\n |  \n |  z\bzf\bfi\bil\bll\bl(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |      \n |      The original string is never truncated.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  f\bfr\bro\bom\bmh\bhe\bex\bx(string, /) from builtins.type\n |      Create a bytes object from a string of hexadecimal numbers.\n |      \n |      Spaces between two numbers are accepted.\n |      Example: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  m\bma\bak\bke\bet\btr\bra\ban\bns\bs(frm, to, /)\n |      Return a translation table useable for the bytes or bytearray translate method.\n |      \n |      The returned table will be one where each byte in frm is mapped to the byte at\n |      the same position in to.\n |      \n |      The bytes objects frm and to must be of the same length.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'bytes'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.bytes' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'bytes'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.bytes' is not a callable object\n"
        },
        {
            "acResult": "bytearray",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Construct a mutable bytearray object from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - a bytes or a buffer object\n  - any object implementing the buffer API.\n  - an integer",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class bytearray in \n\n.\b.b\bby\byt\bte\bea\bar\brr\bra\bay\by = class bytearray(object)\n |  bytearray(iterable_of_ints) -> bytearray\n |  bytearray(string, encoding[, errors]) -> bytearray\n |  bytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\n |  bytearray(int) -> bytes array of size given by the parameter initialized with null bytes\n |  bytearray() -> empty bytes array\n |  \n |  Construct a mutable bytearray object from:\n |    - an iterable yielding integers in range(256)\n |    - a text string encoded using the specified encoding\n |    - a bytes or a buffer object\n |    - any object implementing the buffer API.\n |    - an integer\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |  \n |  _\b__\b_a\bal\bll\blo\boc\bc_\b__\b_(...)\n |      B.__alloc__() -> int\n |      \n |      Return the number of bytes actually allocated.\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return key in self.\n |  \n |  _\b__\b_d\bde\bel\bli\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Delete self[key].\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bia\bad\bdd\bd_\b__\b_(self, value, /)\n |      Implement self+=value.\n |  \n |  _\b__\b_i\bim\bmu\bul\bl_\b__\b_(self, value, /)\n |      Implement self*=value.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_m\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return self%value.\n |  \n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(self, /)\n |      Return state information for pickling.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b_e\bex\bx_\b__\b_(self, proto=0, /)\n |      Return state information for pickling.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\brm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return value%self.\n |  \n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |  \n |  _\b__\b_s\bse\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, value, /)\n |      Set self[key] to value.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Returns the size of the bytearray object in memory, in bytes.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  a\bap\bpp\bpe\ben\bnd\bd(self, item, /)\n |      Append a single item to the end of the bytearray.\n |      \n |      item\n |        The item to be appended.\n |  \n |  c\bca\bap\bpi\bit\bta\bal\bli\biz\bze\be(...)\n |      B.capitalize() -> copy of B\n |      \n |      Return a copy of B with only its first character capitalized (ASCII)\n |      and the rest lower-cased.\n |  \n |  c\bce\ben\bnt\bte\ber\br(self, width, fillchar=b' ', /)\n |      Return a centered string of length width.\n |      \n |      Padding is done using the specified fill character.\n |  \n |  c\bcl\ble\bea\bar\br(self, /)\n |      Remove all items from the bytearray.\n |  \n |  c\bco\bop\bpy\by(self, /)\n |      Return a copy of B.\n |  \n |  c\bco\bou\bun\bnt\bt(...)\n |      B.count(sub[, start[, end]]) -> int\n |      \n |      Return the number of non-overlapping occurrences of subsection sub in\n |      bytes B[start:end].  Optional arguments start and end are interpreted\n |      as in slice notation.\n |  \n |  d\bde\bec\bco\bod\bde\be(self, /, encoding='utf-8', errors='strict')\n |      Decode the bytearray using the codec registered for encoding.\n |      \n |      encoding\n |        The encoding with which to decode the bytearray.\n |      errors\n |        The error handling scheme to use for the handling of decoding errors.\n |        The default is 'strict' meaning that decoding errors raise a\n |        UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n |        as well as any other name registered with codecs.register_error that\n |        can handle UnicodeDecodeErrors.\n |  \n |  e\ben\bnd\bds\bsw\bwi\bit\bth\bh(...)\n |      B.endswith(suffix[, start[, end]]) -> bool\n |      \n |      Return True if B ends with the specified suffix, False otherwise.\n |      With optional start, test B beginning at that position.\n |      With optional end, stop comparing B at that position.\n |      suffix can also be a tuple of bytes to try.\n |  \n |  e\bex\bxp\bpa\ban\bnd\bdt\bta\bab\bbs\bs(self, /, tabsize=8)\n |      Return a copy where all tab characters are expanded using spaces.\n |      \n |      If tabsize is not given, a tab size of 8 characters is assumed.\n |  \n |  e\bex\bxt\bte\ben\bnd\bd(self, iterable_of_ints, /)\n |      Append all the items from the iterator or sequence to the end of the bytearray.\n |      \n |      iterable_of_ints\n |        The iterable of items to append.\n |  \n |  f\bfi\bin\bnd\bd(...)\n |      B.find(sub[, start[, end]]) -> int\n |      \n |      Return the lowest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Return -1 on failure.\n |  \n |  h\bhe\bex\bx(...)\n |      Create a str of hexadecimal numbers from a bytearray object.\n |      \n |        sep\n |          An optional single character or byte to separate hex bytes.\n |        bytes_per_sep\n |          How many bytes between separators.  Positive values count from the\n |          right, negative values count from the left.\n |      \n |      Example:\n |      >>> value = bytearray([0xb9, 0x01, 0xef])\n |      >>> value.hex()\n |      'b901ef'\n |      >>> value.hex(':')\n |      'b9:01:ef'\n |      >>> value.hex(':', 2)\n |      'b9:01ef'\n |      >>> value.hex(':', -2)\n |      'b901:ef'\n |  \n |  i\bin\bnd\bde\bex\bx(...)\n |      B.index(sub[, start[, end]]) -> int\n |      \n |      Return the lowest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Raises ValueError when the subsection is not found.\n |  \n |  i\bin\bns\bse\ber\brt\bt(self, index, item, /)\n |      Insert a single item into the bytearray before the given index.\n |      \n |      index\n |        The index where the value is to be inserted.\n |      item\n |        The item to be inserted.\n |  \n |  i\bis\bsa\bal\bln\bnu\bum\bm(...)\n |      B.isalnum() -> bool\n |      \n |      Return True if all characters in B are alphanumeric\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bsa\bal\blp\bph\bha\ba(...)\n |      B.isalpha() -> bool\n |      \n |      Return True if all characters in B are alphabetic\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bsa\bas\bsc\bci\bii\bi(...)\n |      B.isascii() -> bool\n |      \n |      Return True if B is empty or all characters in B are ASCII,\n |      False otherwise.\n |  \n |  i\bis\bsd\bdi\big\bgi\bit\bt(...)\n |      B.isdigit() -> bool\n |      \n |      Return True if all characters in B are digits\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bsl\blo\bow\bwe\ber\br(...)\n |      B.islower() -> bool\n |      \n |      Return True if all cased characters in B are lowercase and there is\n |      at least one cased character in B, False otherwise.\n |  \n |  i\bis\bss\bsp\bpa\bac\bce\be(...)\n |      B.isspace() -> bool\n |      \n |      Return True if all characters in B are whitespace\n |      and there is at least one character in B, False otherwise.\n |  \n |  i\bis\bst\bti\bit\btl\ble\be(...)\n |      B.istitle() -> bool\n |      \n |      Return True if B is a titlecased string and there is at least one\n |      character in B, i.e. uppercase characters may only follow uncased\n |      characters and lowercase characters only cased ones. Return False\n |      otherwise.\n |  \n |  i\bis\bsu\bup\bpp\bpe\ber\br(...)\n |      B.isupper() -> bool\n |      \n |      Return True if all cased characters in B are uppercase and there is\n |      at least one cased character in B, False otherwise.\n |  \n |  j\bjo\boi\bin\bn(self, iterable_of_bytes, /)\n |      Concatenate any number of bytes/bytearray objects.\n |      \n |      The bytearray whose method is called is inserted in between each pair.\n |      \n |      The result is returned as a new bytearray object.\n |  \n |  l\blj\bju\bus\bst\bt(self, width, fillchar=b' ', /)\n |      Return a left-justified string of length width.\n |      \n |      Padding is done using the specified fill character.\n |  \n |  l\blo\bow\bwe\ber\br(...)\n |      B.lower() -> copy of B\n |      \n |      Return a copy of B with all ASCII characters converted to lowercase.\n |  \n |  l\bls\bst\btr\bri\bip\bp(self, bytes=None, /)\n |      Strip leading bytes contained in the argument.\n |      \n |      If the argument is omitted or None, strip leading ASCII whitespace.\n |  \n |  p\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the bytearray into three parts using the given separator.\n |      \n |      This will search for the separator sep in the bytearray. If the separator is\n |      found, returns a 3-tuple containing the part before the separator, the\n |      separator itself, and the part after it as new bytearray objects.\n |      \n |      If the separator is not found, returns a 3-tuple containing the copy of the\n |      original bytearray object and two empty bytearray objects.\n |  \n |  p\bpo\bop\bp(self, index=-1, /)\n |      Remove and return a single item from B.\n |      \n |        index\n |          The index from where to remove the item.\n |          -1 (the default value) means remove the last item.\n |      \n |      If no index argument is given, will pop the last item.\n |  \n |  r\bre\bem\bmo\bov\bve\be(self, value, /)\n |      Remove the first occurrence of a value in the bytearray.\n |      \n |      value\n |        The value to remove.\n |  \n |  r\bre\bep\bpl\bla\bac\bce\be(self, old, new, count=-1, /)\n |      Return a copy with all occurrences of substring old replaced by new.\n |      \n |        count\n |          Maximum number of occurrences to replace.\n |          -1 (the default value) means replace all occurrences.\n |      \n |      If the optional argument count is given, only the first count occurrences are\n |      replaced.\n |  \n |  r\bre\bev\bve\ber\brs\bse\be(self, /)\n |      Reverse the order of the values in B in place.\n |  \n |  r\brf\bfi\bin\bnd\bd(...)\n |      B.rfind(sub[, start[, end]]) -> int\n |      \n |      Return the highest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Return -1 on failure.\n |  \n |  r\bri\bin\bnd\bde\bex\bx(...)\n |      B.rindex(sub[, start[, end]]) -> int\n |      \n |      Return the highest index in B where subsection sub is found,\n |      such that sub is contained within B[start,end].  Optional\n |      arguments start and end are interpreted as in slice notation.\n |      \n |      Raise ValueError when the subsection is not found.\n |  \n |  r\brj\bju\bus\bst\bt(self, width, fillchar=b' ', /)\n |      Return a right-justified string of length width.\n |      \n |      Padding is done using the specified fill character.\n |  \n |  r\brp\bpa\bar\brt\bti\bit\bti\bio\bon\bn(self, sep, /)\n |      Partition the bytearray into three parts using the given separator.\n |      \n |      This will search for the separator sep in the bytearray, starting at the end.\n |      If the separator is found, returns a 3-tuple containing the part before the\n |      separator, the separator itself, and the part after it as new bytearray\n |      objects.\n |      \n |      If the separator is not found, returns a 3-tuple containing two empty bytearray\n |      objects and the copy of the original bytearray object.\n |  \n |  r\brs\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the sections in the bytearray, using sep as the delimiter.\n |      \n |        sep\n |          The delimiter according which to split the bytearray.\n |          None (the default value) means split on ASCII whitespace characters\n |          (space, tab, return, newline, formfeed, vertical tab).\n |        maxsplit\n |          Maximum number of splits to do.\n |          -1 (the default value) means no limit.\n |      \n |      Splitting is done starting at the end of the bytearray and working to the front.\n |  \n |  r\brs\bst\btr\bri\bip\bp(self, bytes=None, /)\n |      Strip trailing bytes contained in the argument.\n |      \n |      If the argument is omitted or None, strip trailing ASCII whitespace.\n |  \n |  s\bsp\bpl\bli\bit\bt(self, /, sep=None, maxsplit=-1)\n |      Return a list of the sections in the bytearray, using sep as the delimiter.\n |      \n |      sep\n |        The delimiter according which to split the bytearray.\n |        None (the default value) means split on ASCII whitespace characters\n |        (space, tab, return, newline, formfeed, vertical tab).\n |      maxsplit\n |        Maximum number of splits to do.\n |        -1 (the default value) means no limit.\n |  \n |  s\bsp\bpl\bli\bit\btl\bli\bin\bne\bes\bs(self, /, keepends=False)\n |      Return a list of the lines in the bytearray, breaking at line boundaries.\n |      \n |      Line breaks are not included in the resulting list unless keepends is given and\n |      true.\n |  \n |  s\bst\bta\bar\brt\bts\bsw\bwi\bit\bth\bh(...)\n |      B.startswith(prefix[, start[, end]]) -> bool\n |      \n |      Return True if B starts with the specified prefix, False otherwise.\n |      With optional start, test B beginning at that position.\n |      With optional end, stop comparing B at that position.\n |      prefix can also be a tuple of bytes to try.\n |  \n |  s\bst\btr\bri\bip\bp(self, bytes=None, /)\n |      Strip leading and trailing bytes contained in the argument.\n |      \n |      If the argument is omitted or None, strip leading and trailing ASCII whitespace.\n |  \n |  s\bsw\bwa\bap\bpc\bca\bas\bse\be(...)\n |      B.swapcase() -> copy of B\n |      \n |      Return a copy of B with uppercase ASCII characters converted\n |      to lowercase ASCII and vice versa.\n |  \n |  t\bti\bit\btl\ble\be(...)\n |      B.title() -> copy of B\n |      \n |      Return a titlecased version of B, i.e. ASCII words start with uppercase\n |      characters, all remaining cased characters have lowercase.\n |  \n |  t\btr\bra\ban\bns\bsl\bla\bat\bte\be(self, table, /, delete=b'')\n |      Return a copy with each character mapped by the given translation table.\n |      \n |        table\n |          Translation table, which must be a bytes object of length 256.\n |      \n |      All characters occurring in the optional argument delete are removed.\n |      The remaining characters are mapped through the given translation table.\n |  \n |  u\bup\bpp\bpe\ber\br(...)\n |      B.upper() -> copy of B\n |      \n |      Return a copy of B with all ASCII characters converted to uppercase.\n |  \n |  z\bzf\bfi\bil\bll\bl(self, width, /)\n |      Pad a numeric string with zeros on the left, to fill a field of the given width.\n |      \n |      The original string is never truncated.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  f\bfr\bro\bom\bmh\bhe\bex\bx(string, /) from builtins.type\n |      Create a bytearray object from a string of hexadecimal numbers.\n |      \n |      Spaces between two numbers are accepted.\n |      Example: bytearray.fromhex('B9 01EF') -> bytearray(b'\\\\xb9\\\\x01\\\\xef')\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  m\bma\bak\bke\bet\btr\bra\ban\bns\bs(frm, to, /)\n |      Return a translation table useable for the bytes or bytearray translate method.\n |      \n |      The returned table will be one where each byte in frm is mapped to the byte at\n |      the same position in to.\n |      \n |      The bytes objects frm and to must be of the same length.\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'bytearray'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.bytearray' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'bytearray'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.bytearray' is not a callable object\n"
        },
        {
            "acResult": "memoryview",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a new memoryview object which references the given object.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "object",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "bool",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Returns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class bool in \n\n.\b.b\bbo\boo\bol\bl = class bool(int)\n |  bool(x) -> bool\n |  \n |  Returns True when the argument x is true, False otherwise.\n |  The builtins True and False are the only two instances of the class bool.\n |  The class bool is a subclass of the class int, and cannot be subclassed.\n |  \n |  Method resolution order:\n |      bool\n |      int\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return self&value.\n |  \n |  _\b__\b_o\bor\br_\b__\b_(self, value, /)\n |      Return self|value.\n |  \n |  _\b__\b_r\bra\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return value&self.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\bro\bor\br_\b__\b_(self, value, /)\n |      Return value|self.\n |  \n |  _\b__\b_r\brx\bxo\bor\br_\b__\b_(self, value, /)\n |      Return value^self.\n |  \n |  _\b__\b_x\bxo\bor\br_\b__\b_(self, value, /)\n |      Return self^value.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from int:\n |  \n |  _\b__\b_a\bab\bbs\bs_\b__\b_(self, /)\n |      abs(self)\n |  \n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |  \n |  _\b__\b_b\bbo\boo\bol\bl_\b__\b_(self, /)\n |      self != 0\n |  \n |  _\b__\b_c\bce\bei\bil\bl_\b__\b_(...)\n |      Ceiling of an Integral returns itself.\n |  \n |  _\b__\b_d\bdi\biv\bvm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return divmod(self, value).\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_f\bfl\blo\boa\bat\bt_\b__\b_(self, /)\n |      float(self)\n |  \n |  _\b__\b_f\bfl\blo\boo\bor\br_\b__\b_(...)\n |      Flooring an Integral returns itself.\n |  \n |  _\b__\b_f\bfl\blo\boo\bor\brd\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return self//value.\n |  \n |  _\b__\b_f\bfo\bor\brm\bma\bat\bt_\b__\b_(self, format_spec, /)\n |      Default object formatter.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\btn\bne\bew\bwa\bar\brg\bgs\bs_\b__\b_(self, /)\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_i\bin\bnd\bde\bex\bx_\b__\b_(self, /)\n |      Return self converted to an integer, if self is suitable for use as an index into a list.\n |  \n |  _\b__\b_i\bin\bnt\bt_\b__\b_(self, /)\n |      int(self)\n |  \n |  _\b__\b_i\bin\bnv\bve\ber\brt\bt_\b__\b_(self, /)\n |      ~self\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\bls\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return self<<value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_m\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return self%value.\n |  \n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_n\bne\beg\bg_\b__\b_(self, /)\n |      -self\n |  \n |  _\b__\b_p\bpo\bos\bs_\b__\b_(self, /)\n |      +self\n |  \n |  _\b__\b_p\bpo\bow\bw_\b__\b_(self, value, mod=None, /)\n |      Return pow(self, value, mod).\n |  \n |  _\b__\b_r\bra\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return value+self.\n |  \n |  _\b__\b_r\brd\bdi\biv\bvm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return divmod(value, self).\n |  \n |  _\b__\b_r\brf\bfl\blo\boo\bor\brd\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return value//self.\n |  \n |  _\b__\b_r\brl\bls\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return value<<self.\n |  \n |  _\b__\b_r\brm\bmo\bod\bd_\b__\b_(self, value, /)\n |      Return value%self.\n |  \n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |  \n |  _\b__\b_r\bro\bou\bun\bnd\bd_\b__\b_(...)\n |      Rounding an Integral returns itself.\n |      Rounding with an ndigits argument also returns an integer.\n |  \n |  _\b__\b_r\brp\bpo\bow\bw_\b__\b_(self, value, mod=None, /)\n |      Return pow(value, self, mod).\n |  \n |  _\b__\b_r\brr\brs\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return value>>self.\n |  \n |  _\b__\b_r\brs\bsh\bhi\bif\bft\bt_\b__\b_(self, value, /)\n |      Return self>>value.\n |  \n |  _\b__\b_r\brs\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return value-self.\n |  \n |  _\b__\b_r\brt\btr\bru\bue\bed\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return value/self.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Returns size in memory, in bytes.\n |  \n |  _\b__\b_s\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return self-value.\n |  \n |  _\b__\b_t\btr\bru\bue\bed\bdi\biv\bv_\b__\b_(self, value, /)\n |      Return self/value.\n |  \n |  _\b__\b_t\btr\bru\bun\bnc\bc_\b__\b_(...)\n |      Truncating an Integral returns itself.\n |  \n |  a\bas\bs_\b_i\bin\bnt\bte\beg\bge\ber\br_\b_r\bra\bat\bti\bio\bo(self, /)\n |      Return integer ratio.\n |      \n |      Return a pair of integers, whose ratio is exactly equal to the original int\n |      and with a positive denominator.\n |      \n |      >>> (10).as_integer_ratio()\n |      (10, 1)\n |      >>> (-10).as_integer_ratio()\n |      (-10, 1)\n |      >>> (0).as_integer_ratio()\n |      (0, 1)\n |  \n |  b\bbi\bit\bt_\b_l\ble\ben\bng\bgt\bth\bh(self, /)\n |      Number of bits necessary to represent self in binary.\n |      \n |      >>> bin(37)\n |      '0b100101'\n |      >>> (37).bit_length()\n |      6\n |  \n |  c\bco\bon\bnj\bju\bug\bga\bat\bte\be(...)\n |      Returns self, the complex conjugate of any int.\n |  \n |  t\bto\bo_\b_b\bby\byt\bte\bes\bs(self, /, length, byteorder, *, signed=False)\n |      Return an array of bytes representing an integer.\n |      \n |      length\n |        Length of bytes object to use.  An OverflowError is raised if the\n |        integer is not representable with the given number of bytes.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Determines whether two's complement is used to represent the integer.\n |        If signed is False and a negative integer is given, an OverflowError\n |        is raised.\n |  \n |  ----------------------------------------------------------------------\n |  Class methods inherited from int:\n |  \n |  f\bfr\bro\bom\bm_\b_b\bby\byt\bte\bes\bs(bytes, byteorder, *, signed=False) from builtins.type\n |      Return the integer represented by the given array of bytes.\n |      \n |      bytes\n |        Holds the array of bytes to convert.  The argument must either\n |        support the buffer protocol or be an iterable object producing bytes.\n |        Bytes and bytearray are examples of built-in objects that support the\n |        buffer protocol.\n |      byteorder\n |        The byte order used to represent the integer.  If byteorder is 'big',\n |        the most significant byte is at the beginning of the byte array.  If\n |        byteorder is 'little', the most significant byte is at the end of the\n |        byte array.  To request the native byte order of the host system, use\n |        `sys.byteorder' as the byte order value.\n |      signed\n |        Indicates whether two's complement is used to represent the integer.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from int:\n |  \n |  d\bde\ben\bno\bom\bmi\bin\bna\bat\bto\bor\br\n |      the denominator of a rational number in lowest terms\n |  \n |  i\bim\bma\bag\bg\n |      the imaginary part of a complex number\n |  \n |  n\bnu\bum\bme\ber\bra\bat\bto\bor\br\n |      the numerator of a rational number in lowest terms\n |  \n |  r\bre\bea\bal\bl\n |      the real part of a complex number\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'bool'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.bool' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'bool'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.bool' is not a callable object\n"
        },
        {
            "acResult": "slice",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class slice in \n\n.\b.s\bsl\bli\bic\bce\be = class slice(object)\n |  slice(stop)\n |  slice(start, stop[, step])\n |  \n |  Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  i\bin\bnd\bdi\bic\bce\bes\bs(...)\n |      S.indices(len) -> (start, stop, stride)\n |      \n |      Assuming a sequence of length len, calculate the start and stop\n |      indices, and the stride length of the extended slice described by\n |      S. Out of bounds indices are clipped in a manner consistent with the\n |      handling of normal slices.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  s\bst\bta\bar\brt\bt\n |  \n |  s\bst\bte\bep\bp\n |  \n |  s\bst\bto\bop\bp\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'slice'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.slice' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'slice'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.slice' is not a callable object\n"
        },
        {
            "acResult": "tuple",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": "()",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "function",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute 'function'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'function'\n'.function' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'function'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.function' is not a callable object\nNo Python documentation found for '.function'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'function'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.function' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '.function'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "frozenset",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Build an immutable unordered collection of unique elements.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class frozenset in \n\n.\b.f\bfr\bro\boz\bze\ben\bns\bse\bet\bt = class frozenset(object)\n |  frozenset() -> empty frozenset object\n |  frozenset(iterable) -> frozenset object\n |  \n |  Build an immutable unordered collection of unique elements.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return self&value.\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(...)\n |      x.__contains__(y) <==> y in x.\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_o\bor\br_\b__\b_(self, value, /)\n |      Return self|value.\n |  \n |  _\b__\b_r\bra\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return value&self.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\bro\bor\br_\b__\b_(self, value, /)\n |      Return value|self.\n |  \n |  _\b__\b_r\brs\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return value-self.\n |  \n |  _\b__\b_r\brx\bxo\bor\br_\b__\b_(self, value, /)\n |      Return value^self.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(...)\n |      S.__sizeof__() -> size of S in memory, in bytes\n |  \n |  _\b__\b_s\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return self-value.\n |  \n |  _\b__\b_x\bxo\bor\br_\b__\b_(self, value, /)\n |      Return self^value.\n |  \n |  c\bco\bop\bpy\by(...)\n |      Return a shallow copy of a set.\n |  \n |  d\bdi\bif\bff\bfe\ber\bre\ben\bnc\bce\be(...)\n |      Return the difference of two or more sets as a new set.\n |      \n |      (i.e. all elements that are in this set but not the others.)\n |  \n |  i\bin\bnt\bte\ber\brs\bse\bec\bct\bti\bio\bon\bn(...)\n |      Return the intersection of two sets as a new set.\n |      \n |      (i.e. all elements that are in both sets.)\n |  \n |  i\bis\bsd\bdi\bis\bsj\bjo\boi\bin\bnt\bt(...)\n |      Return True if two sets have a null intersection.\n |  \n |  i\bis\bss\bsu\bub\bbs\bse\bet\bt(...)\n |      Report whether another set contains this set.\n |  \n |  i\bis\bss\bsu\bup\bpe\ber\brs\bse\bet\bt(...)\n |      Report whether this set contains another set.\n |  \n |  s\bsy\bym\bmm\bme\bet\btr\bri\bic\bc_\b_d\bdi\bif\bff\bfe\ber\bre\ben\bnc\bce\be(...)\n |      Return the symmetric difference of two sets as a new set.\n |      \n |      (i.e. all elements that are in exactly one of the sets.)\n |  \n |  u\bun\bni\bio\bon\bn(...)\n |      Return the union of sets as a new set.\n |      \n |      (i.e. all elements that are in either set.)\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'frozenset'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.frozenset' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'frozenset'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.frozenset' is not a callable object\n"
        },
        {
            "acResult": "list",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": "()",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "dict",
            "type": [
                "type",
                "function"
            ],
            "documentation": "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class dict in \n\n.\b.d\bdi\bic\bct\bt = class dict(object)\n |  dict() -> new empty dictionary\n |  dict(mapping) -> new dictionary initialized from a mapping object's\n |      (key, value) pairs\n |  dict(iterable) -> new dictionary initialized as if via:\n |      d = {}\n |      for k, v in iterable:\n |          d[k] = v\n |  dict(**kwargs) -> new dictionary initialized with the name=value pairs\n |      in the keyword argument list.  For example:  dict(one=1, two=2)\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |  \n |  _\b__\b_d\bde\bel\bli\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Delete self[key].\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(...)\n |      x.__getitem__(y) <==> x[y]\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\bre\bev\bve\ber\brs\bse\bed\bd_\b__\b_(self, /)\n |      Return a reverse iterator over the dict keys.\n |  \n |  _\b__\b_s\bse\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, value, /)\n |      Set self[key] to value.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(...)\n |      D.__sizeof__() -> size of D in memory, in bytes\n |  \n |  c\bcl\ble\bea\bar\br(...)\n |      D.clear() -> None.  Remove all items from D.\n |  \n |  c\bco\bop\bpy\by(...)\n |      D.copy() -> a shallow copy of D\n |  \n |  g\bge\bet\bt(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |  \n |  i\bit\bte\bem\bms\bs(...)\n |      D.items() -> a set-like object providing a view on D's items\n |  \n |  k\bke\bey\bys\bs(...)\n |      D.keys() -> a set-like object providing a view on D's keys\n |  \n |  p\bpo\bop\bp(...)\n |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\n |      If key is not found, d is returned if given, otherwise KeyError is raised\n |  \n |  p\bpo\bop\bpi\bit\bte\bem\bm(self, /)\n |      Remove and return a (key, value) pair as a 2-tuple.\n |      \n |      Pairs are returned in LIFO (last-in, first-out) order.\n |      Raises KeyError if the dict is empty.\n |  \n |  s\bse\bet\btd\bde\bef\bfa\bau\bul\blt\bt(self, key, default=None, /)\n |      Insert key with a value of default if key is not in the dictionary.\n |      \n |      Return the value for key if key is in the dictionary, else default.\n |  \n |  u\bup\bpd\bda\bat\bte\be(...)\n |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\n |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\n |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n |      In either case, this is followed by: for k in F:  D[k] = F[k]\n |  \n |  v\bva\bal\blu\bue\bes\bs(...)\n |      D.values() -> an object providing a view on D's values\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  f\bfr\bro\bom\bmk\bke\bey\bys\bs(iterable, value=None, /) from builtins.type\n |      Create a new dictionary with keys from iterable and values set to value.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'dict'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.dict' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'dict'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.dict' is not a callable object\n"
        },
        {
            "acResult": "set",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Build an unordered collection of unique elements.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class set in \n\n.\b.s\bse\bet\bt = class set(object)\n |  set() -> new empty set object\n |  set(iterable) -> new set object\n |  \n |  Build an unordered collection of unique elements.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return self&value.\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(...)\n |      x.__contains__(y) <==> y in x.\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bia\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return self&=value.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_i\bio\bor\br_\b__\b_(self, value, /)\n |      Return self|=value.\n |  \n |  _\b__\b_i\bis\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return self-=value.\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_i\bix\bxo\bor\br_\b__\b_(self, value, /)\n |      Return self^=value.\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_o\bor\br_\b__\b_(self, value, /)\n |      Return self|value.\n |  \n |  _\b__\b_r\bra\ban\bnd\bd_\b__\b_(self, value, /)\n |      Return value&self.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\bro\bor\br_\b__\b_(self, value, /)\n |      Return value|self.\n |  \n |  _\b__\b_r\brs\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return value-self.\n |  \n |  _\b__\b_r\brx\bxo\bor\br_\b__\b_(self, value, /)\n |      Return value^self.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(...)\n |      S.__sizeof__() -> size of S in memory, in bytes\n |  \n |  _\b__\b_s\bsu\bub\bb_\b__\b_(self, value, /)\n |      Return self-value.\n |  \n |  _\b__\b_x\bxo\bor\br_\b__\b_(self, value, /)\n |      Return self^value.\n |  \n |  a\bad\bdd\bd(...)\n |      Add an element to a set.\n |      \n |      This has no effect if the element is already present.\n |  \n |  c\bcl\ble\bea\bar\br(...)\n |      Remove all elements from this set.\n |  \n |  c\bco\bop\bpy\by(...)\n |      Return a shallow copy of a set.\n |  \n |  d\bdi\bif\bff\bfe\ber\bre\ben\bnc\bce\be(...)\n |      Return the difference of two or more sets as a new set.\n |      \n |      (i.e. all elements that are in this set but not the others.)\n |  \n |  d\bdi\bif\bff\bfe\ber\bre\ben\bnc\bce\be_\b_u\bup\bpd\bda\bat\bte\be(...)\n |      Remove all elements of another set from this set.\n |  \n |  d\bdi\bis\bsc\bca\bar\brd\bd(...)\n |      Remove an element from a set if it is a member.\n |      \n |      If the element is not a member, do nothing.\n |  \n |  i\bin\bnt\bte\ber\brs\bse\bec\bct\bti\bio\bon\bn(...)\n |      Return the intersection of two sets as a new set.\n |      \n |      (i.e. all elements that are in both sets.)\n |  \n |  i\bin\bnt\bte\ber\brs\bse\bec\bct\bti\bio\bon\bn_\b_u\bup\bpd\bda\bat\bte\be(...)\n |      Update a set with the intersection of itself and another.\n |  \n |  i\bis\bsd\bdi\bis\bsj\bjo\boi\bin\bnt\bt(...)\n |      Return True if two sets have a null intersection.\n |  \n |  i\bis\bss\bsu\bub\bbs\bse\bet\bt(...)\n |      Report whether another set contains this set.\n |  \n |  i\bis\bss\bsu\bup\bpe\ber\brs\bse\bet\bt(...)\n |      Report whether this set contains another set.\n |  \n |  p\bpo\bop\bp(...)\n |      Remove and return an arbitrary set element.\n |      Raises KeyError if the set is empty.\n |  \n |  r\bre\bem\bmo\bov\bve\be(...)\n |      Remove an element from a set; it must be a member.\n |      \n |      If the element is not a member, raise a KeyError.\n |  \n |  s\bsy\bym\bmm\bme\bet\btr\bri\bic\bc_\b_d\bdi\bif\bff\bfe\ber\bre\ben\bnc\bce\be(...)\n |      Return the symmetric difference of two sets as a new set.\n |      \n |      (i.e. all elements that are in exactly one of the sets.)\n |  \n |  s\bsy\bym\bmm\bme\bet\btr\bri\bic\bc_\b_d\bdi\bif\bff\bfe\ber\bre\ben\bnc\bce\be_\b_u\bup\bpd\bda\bat\bte\be(...)\n |      Update a set with the symmetric difference of itself and another.\n |  \n |  u\bun\bni\bio\bon\bn(...)\n |      Return the union of sets as a new set.\n |      \n |      (i.e. all elements that are in either set.)\n |  \n |  u\bup\bpd\bda\bat\bte\be(...)\n |      Update a set with the union of itself and others.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'set'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.set' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'set'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.set' is not a callable object\n"
        },
        {
            "acResult": "enumerate",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "start",
                        "defaultValue": "0",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "range",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Return an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class range in \n\n.\b.r\bra\ban\bng\bge\be = class range(object)\n |  range(stop) -> range object\n |  range(start, stop[, step]) -> range object\n |  \n |  Return an object that produces a sequence of integers from start (inclusive)\n |  to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\n |  start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\n |  These are exactly the valid indices for a list of 4 elements.\n |  When step is given, it specifies the increment (or decrement).\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_b\bbo\boo\bol\bl_\b__\b_(self, /)\n |      self != 0\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return key in self.\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\bre\bev\bve\ber\brs\bse\bed\bd_\b__\b_(...)\n |      Return a reverse iterator.\n |  \n |  c\bco\bou\bun\bnt\bt(...)\n |      rangeobject.count(value) -> integer -- return number of occurrences of value\n |  \n |  i\bin\bnd\bde\bex\bx(...)\n |      rangeobject.index(value) -> integer -- return index of value.\n |      Raise ValueError if the value is not present.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  s\bst\bta\bar\brt\bt\n |  \n |  s\bst\bte\bep\bp\n |  \n |  s\bst\bto\bop\bp\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'range'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.range' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'range'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.range' is not a callable object\n"
        },
        {
            "acResult": "property",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        \"I am the 'x' property.\"\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "fget",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "fset",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "fdel",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "doc",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "_NotImplementedType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute '_NotImplementedType'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_NotImplementedType'\n'._NotImplementedType' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_NotImplementedType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._NotImplementedType' is not a callable object\nNo Python documentation found for '._NotImplementedType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_NotImplementedType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._NotImplementedType' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '._NotImplementedType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "NotImplemented",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "abs",
            "type": [
                "function"
            ],
            "documentation": "Return the absolute value of the argument.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "all",
            "type": [
                "function"
            ],
            "documentation": "Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "any",
            "type": [
                "function"
            ],
            "documentation": "Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "bin",
            "type": [
                "function"
            ],
            "documentation": "Return the binary representation of an integer.\n\n>>> bin(2796202)\n'0b1010101010101010101010'",
            "version": 0,
            "params": [
                {
                    "name": "number"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "number",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "breakpoint",
            "type": [
                "function"
            ],
            "documentation": "Call sys.breakpointhook(*args, **kws).  sys.breakpointhook() must accept\nwhatever arguments are passed.\n\nBy default, this drops you into the pdb debugger.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: built-in function breakpoint in \n\n.\b.b\bbr\bre\bea\bak\bkp\bpo\boi\bin\bnt\bt = breakpoint(...)\n    breakpoint(*args, **kws)\n    \n    Call sys.breakpointhook(*args, **kws).  sys.breakpointhook() must accept\n    whatever arguments are passed.\n    \n    By default, this drops you into the pdb debugger.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function breakpoint>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.breakpoint' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function breakpoint>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.breakpoint' is not a callable object\n"
        },
        {
            "acResult": "callable",
            "type": [
                "function"
            ],
            "documentation": "Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "chr",
            "type": [
                "function"
            ],
            "documentation": "Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.",
            "version": 0,
            "params": [
                {
                    "name": "i"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "i",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "_PathLike",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute '_PathLike'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_PathLike'\n'._PathLike' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_PathLike'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._PathLike' is not a callable object\nNo Python documentation found for '._PathLike'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_PathLike'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._PathLike' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '._PathLike'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "aiter",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ],
            "errors": "module 'builtins' has no attribute 'aiter'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'aiter'\n'.aiter' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'aiter'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.aiter' is not a callable object\nNo Python documentation found for '.aiter'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'aiter'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.aiter' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '.aiter'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "delattr",
            "type": [
                "function"
            ],
            "documentation": "Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y''",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                },
                {
                    "name": "name"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "dir",
            "type": [
                "function"
            ],
            "documentation": "If called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes.",
            "version": 0,
            "params": [
                {
                    "name": "o",
                    "defaultValue": "Ellipsis"
                }
            ],
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: built-in function dir in \n\n.\b.d\bdi\bir\br = dir(...)\n    dir([object]) -> list of strings\n    \n    If called without an argument, return the names in the current scope.\n    Else, return an alphabetized list of names comprising (some of) the attributes\n    of the given object, and of attributes reachable from it.\n    If the object supplies a method named __dir__, it will be used; otherwise\n    the default dir() logic is used and returns:\n      for a module object: the module's attributes.\n      for a class object:  its attributes, and recursively the attributes\n        of its bases.\n      for any other object: its attributes, its class's attributes, and\n        recursively the attributes of its class's base classes.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function dir>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.dir' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function dir>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.dir' is not a callable object\n"
        },
        {
            "acResult": "divmod",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "y"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "x",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "y",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "eval",
            "type": [
                "function"
            ],
            "documentation": "Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.",
            "version": 0,
            "params": [
                {
                    "name": "source"
                },
                {
                    "name": "globals",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "locals",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "source",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "globals",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "locals",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "exec",
            "type": [
                "function"
            ],
            "documentation": "Execute the given source in the context of globals and locals.\n\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.",
            "version": 0,
            "params": [
                {
                    "name": "source"
                },
                {
                    "name": "globals",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "locals",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "source",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "globals",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "locals",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "filter",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class filter in \n\n.\b.f\bfi\bil\blt\bte\ber\br = class filter(object)\n |  filter(function or None, iterable) --> filter object\n |  \n |  Return an iterator yielding those items of iterable for which function(item)\n |  is true. If function is None, return the items that are true.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_n\bne\bex\bxt\bt_\b__\b_(self, /)\n |      Implement next(self).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'filter'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.filter' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'filter'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.filter' is not a callable object\n"
        },
        {
            "acResult": "getattr",
            "type": [
                "function",
                "function",
                "function",
                "function"
            ],
            "documentation": "Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case.",
            "version": 0,
            "params": [
                {
                    "name": "object"
                },
                {
                    "name": "name"
                }
            ]
        },
        {
            "acResult": "globals",
            "type": [
                "function"
            ],
            "documentation": "Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa.",
            "version": 0
        },
        {
            "acResult": "hasattr",
            "type": [
                "function"
            ],
            "documentation": "Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                },
                {
                    "name": "name"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "hash",
            "type": [
                "function"
            ],
            "documentation": "Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "help",
            "type": [
                "function"
            ],
            "documentation": "Define the builtin 'help'.\n\nThis is a wrapper around pydoc.help that provides a helpful message\nwhen 'help' is typed at the Python interactive prompt.\n\nCalling help() at the Python prompt starts an interactive help session.\nCalling help(thing) prints help for the python object 'thing'.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "hex",
            "type": [
                "function"
            ],
            "documentation": "Return the hexadecimal representation of an integer.\n\n>>> hex(12648430)\n'0xc0ffee'",
            "version": 0,
            "params": [
                {
                    "name": "number"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "number",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "id",
            "type": [
                "function"
            ],
            "documentation": "Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "input",
            "type": [
                "function"
            ],
            "documentation": "Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available.",
            "version": 0,
            "params": [
                {
                    "name": "prompt",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "prompt",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "iter",
            "type": [
                "function",
                "function",
                "function"
            ],
            "documentation": "Get an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ],
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: built-in function iter in \n\n.\b.i\bit\bte\ber\br = iter(...)\n    iter(iterable) -> iterator\n    iter(callable, sentinel) -> iterator\n    \n    Get an iterator from an object.  In the first form, the argument must\n    supply its own iterator, or be a sequence.\n    In the second form, the callable is called until it returns the sentinel.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function iter>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.iter' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function iter>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.iter' is not a callable object\n"
        },
        {
            "acResult": "isinstance",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                },
                {
                    "name": "class_or_tuple"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "class_or_tuple",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "issubclass",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Return whether 'cls' is a derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...`` etc.",
            "version": 0,
            "params": [
                {
                    "name": "cls"
                },
                {
                    "name": "class_or_tuple"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "class_or_tuple",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "len",
            "type": [
                "function"
            ],
            "documentation": "Return the number of items in a container.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "locals",
            "type": [
                "function"
            ],
            "documentation": "Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees.",
            "version": 0
        },
        {
            "acResult": "map",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Make an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class map in \n\n.\b.m\bma\bap\bp = class map(object)\n |  map(func, *iterables) --> map object\n |  \n |  Make an iterator that computes the function using arguments from\n |  each of the iterables.  Stops when the shortest iterable is exhausted.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_n\bne\bex\bxt\bt_\b__\b_(self, /)\n |      Implement next(self).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'map'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.map' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'map'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.map' is not a callable object\n"
        },
        {
            "acResult": "max",
            "type": [
                "function",
                "function",
                "function",
                "function",
                "function",
                "function"
            ],
            "documentation": "With a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ]
        },
        {
            "acResult": "min",
            "type": [
                "function",
                "function",
                "function",
                "function",
                "function",
                "function"
            ],
            "documentation": "With a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ]
        },
        {
            "acResult": "next",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Return the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration.",
            "version": 0,
            "params": [
                {
                    "name": "iterator"
                }
            ]
        },
        {
            "acResult": "oct",
            "type": [
                "function"
            ],
            "documentation": "Return the octal representation of an integer.\n\n>>> oct(342391)\n'0o1234567'",
            "version": 0,
            "params": [
                {
                    "name": "number"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "number",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "open",
            "type": [
                "function",
                "function",
                "function"
            ],
            "documentation": "Open file and return a stream.  Raise OSError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), 'x' for creating and writing to a new file, and\n'a' for appending (which on some Unix systems, means that all writes\nappend to the end of the file regardless of the current seek position).\nIn text mode, if encoding is not specified the encoding used is platform\ndependent: locale.getpreferredencoding(False) is called to get the\ncurrent locale encoding. (For reading and writing raw bytes use binary\nmode and leave encoding unspecified.) The available modes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'x'       create a new file and open it for writing\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n'U'       universal newline mode (deprecated)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation. The 'x' mode implies 'w' and\nraises an `FileExistsError` if the file already exists.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\n'U' mode is deprecated and will raise an exception in future versions\nof Python.  It has no effect in Python 3.  Use newline to control\nuniversal newlines mode.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register or run 'help(codecs.Codec)'\nfor a list of the permitted encoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nA custom opener can be used by passing a callable as *opener*. The\nunderlying file descriptor for the file object is then obtained by\ncalling *opener* with (*file*, *flags*). *opener* must return an open\nfile descriptor (passing os.open as *opener* results in functionality\nsimilar to passing None).\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.",
            "version": 0,
            "params": [
                {
                    "name": "file"
                },
                {
                    "name": "mode",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "buffering",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "encoding",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "errors",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "newline",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "closefd",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "opener",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "file",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "mode",
                        "defaultValue": "'r'",
                        "argType": "None"
                    },
                    {
                        "name": "buffering",
                        "defaultValue": "-1",
                        "argType": "None"
                    },
                    {
                        "name": "encoding",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "errors",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "newline",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "closefd",
                        "defaultValue": "True",
                        "argType": "None"
                    },
                    {
                        "name": "opener",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "ord",
            "type": [
                "function"
            ],
            "documentation": "Return the Unicode code point for a one-character string.",
            "version": 0,
            "params": [
                {
                    "name": "c"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "c",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "print",
            "type": [
                "function"
            ],
            "documentation": "Prints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream.",
            "version": 0,
            "errors": "unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function print>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'signature'Traceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function print>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 238, in <module>\n    del item['signature']\nKeyError: 'signature'\n"
        },
        {
            "acResult": "_SupportsPow2",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute '_SupportsPow2'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsPow2'\n'._SupportsPow2' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsPow2'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._SupportsPow2' is not a callable object\nNo Python documentation found for '._SupportsPow2'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsPow2'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._SupportsPow2' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '._SupportsPow2'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "_SupportsPow3",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute '_SupportsPow3'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsPow3'\n'._SupportsPow3' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsPow3'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._SupportsPow3' is not a callable object\nNo Python documentation found for '._SupportsPow3'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute '_SupportsPow3'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '._SupportsPow3' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '._SupportsPow3'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "pow",
            "type": [
                "function",
                "function",
                "function",
                "function",
                "function",
                "function",
                "function",
                "function",
                "function",
                "function"
            ],
            "documentation": "Equivalent to base**exp with 2 arguments or base**exp % mod with 3 arguments\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form.",
            "version": 0,
            "params": [
                {
                    "name": "base"
                },
                {
                    "name": "exp"
                },
                {
                    "name": "mod",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "base",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "exp",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "mod",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "reversed",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Return a reverse iterator over the values of the given sequence.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "sequence",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "repr",
            "type": [
                "function"
            ],
            "documentation": "Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "round",
            "type": [
                "function",
                "function",
                "function"
            ],
            "documentation": "Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative.",
            "version": 0,
            "params": [
                {
                    "name": "number"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "number",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "ndigits",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "setattr",
            "type": [
                "function"
            ],
            "documentation": "Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v''",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                },
                {
                    "name": "name"
                },
                {
                    "name": "value"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "value",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "sorted",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [
                    {
                        "name": "key",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "reverse",
                        "defaultValue": "False",
                        "argType": "None"
                    }
                ],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "sum",
            "type": [
                "function",
                "function",
                "function",
                "function"
            ],
            "documentation": "Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types.",
            "version": 0,
            "params": [
                {
                    "name": "iterable"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "start",
                        "defaultValue": "0",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "zip",
            "type": [
                "type",
                "function"
            ],
            "documentation": ">>> list(zip('abcdefg', range(3), range(4)))\n   [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]\n\nThe zip object yields n-length tuples, where n is the number of iterables\npassed as positional arguments to zip().  The i-th element in every tuple\ncomes from the i-th iterable argument to zip().  This continues until the\nshortest argument is exhausted.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class zip in \n\n.\b.z\bzi\bip\bp = class zip(object)\n |  zip(*iterables) --> A zip object yielding tuples until an input is exhausted.\n |  \n |     >>> list(zip('abcdefg', range(3), range(4)))\n |     [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]\n |  \n |  The zip object yields n-length tuples, where n is the number of iterables\n |  passed as positional arguments to zip().  The i-th element in every tuple\n |  comes from the i-th iterable argument to zip().  This continues until the\n |  shortest argument is exhausted.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_n\bne\bex\bxt\bt_\b__\b_(self, /)\n |      Implement next(self).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'zip'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.zip' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'zip'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.zip' is not a callable object\n"
        },
        {
            "acResult": "__import__",
            "type": [
                "function"
            ],
            "documentation": "__import__(name, globals=None, locals=None, fromlist=(), level=0) -> module\n\nImport a module. Because this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...'', or an\nempty list to emulate ``import name''.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module.",
            "version": 0,
            "params": [
                {
                    "name": "name"
                }
            ]
        },
        {
            "acResult": "ellipsis",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'builtins' has no attribute 'ellipsis'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'ellipsis'\n'.ellipsis' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'ellipsis'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.ellipsis' is not a callable object\nNo Python documentation found for '.ellipsis'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'builtins' has no attribute 'ellipsis'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.ellipsis' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for '.ellipsis'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "Ellipsis",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "BaseException",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Common base class for all exceptions",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class BaseException in \n\n.\b.B\bBa\bas\bse\beE\bEx\bxc\bce\bep\bpt\bti\bio\bon\bn = class BaseException(object)\n |  Common base class for all exceptions\n |  \n |  Built-in subclasses:\n |      Exception\n |      GeneratorExit\n |      KeyboardInterrupt\n |      SystemExit\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'BaseException'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.BaseException' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'BaseException'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.BaseException' is not a callable object\n"
        },
        {
            "acResult": "GeneratorExit",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Request that a generator exit.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class GeneratorExit in \n\n.\b.G\bGe\ben\bne\ber\bra\bat\bto\bor\brE\bEx\bxi\bit\bt = class GeneratorExit(BaseException)\n |  Request that a generator exit.\n |  \n |  Method resolution order:\n |      GeneratorExit\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'GeneratorExit'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.GeneratorExit' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'GeneratorExit'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.GeneratorExit' is not a callable object\n"
        },
        {
            "acResult": "KeyboardInterrupt",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Program interrupted by user.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class KeyboardInterrupt in \n\n.\b.K\bKe\bey\byb\bbo\boa\bar\brd\bdI\bIn\bnt\bte\ber\brr\bru\bup\bpt\bt = class KeyboardInterrupt(BaseException)\n |  Program interrupted by user.\n |  \n |  Method resolution order:\n |      KeyboardInterrupt\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'KeyboardInterrupt'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.KeyboardInterrupt' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'KeyboardInterrupt'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.KeyboardInterrupt' is not a callable object\n"
        },
        {
            "acResult": "SystemExit",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Request to exit from the interpreter.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class SystemExit in \n\n.\b.S\bSy\bys\bst\bte\bem\bmE\bEx\bxi\bit\bt = class SystemExit(BaseException)\n |  Request to exit from the interpreter.\n |  \n |  Method resolution order:\n |      SystemExit\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  c\bco\bod\bde\be\n |      exception code\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from BaseException:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'SystemExit'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.SystemExit' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'SystemExit'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.SystemExit' is not a callable object\n"
        },
        {
            "acResult": "Exception",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Common base class for all non-exit exceptions.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class Exception in \n\n.\b.E\bEx\bxc\bce\bep\bpt\bti\bio\bon\bn = class Exception(BaseException)\n |  Common base class for all non-exit exceptions.\n |  \n |  Method resolution order:\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      ArithmeticError\n |      AssertionError\n |      AttributeError\n |      BufferError\n |      ... and 15 other subclasses\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'Exception'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.Exception' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'Exception'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.Exception' is not a callable object\n"
        },
        {
            "acResult": "StopIteration",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Signal the end from iterator.__next__().",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class StopIteration in \n\n.\b.S\bSt\bto\bop\bpI\bIt\bte\ber\bra\bat\bti\bio\bon\bn = class StopIteration(Exception)\n |  Signal the end from iterator.__next__().\n |  \n |  Method resolution order:\n |      StopIteration\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  v\bva\bal\blu\bue\be\n |      generator return value\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from Exception:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'StopIteration'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.StopIteration' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'StopIteration'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.StopIteration' is not a callable object\n"
        },
        {
            "acResult": "OSError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Base class for I/O related errors.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class OSError in \n\n.\b.O\bOS\bSE\bEr\brr\bro\bor\br = class OSError(Exception)\n |  Base class for I/O related errors.\n |  \n |  Method resolution order:\n |      OSError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      BlockingIOError\n |      ChildProcessError\n |      ConnectionError\n |      FileExistsError\n |      ... and 7 other subclasses\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  c\bch\bha\bar\bra\bac\bct\bte\ber\brs\bs_\b_w\bwr\bri\bit\btt\bte\ben\bn\n |  \n |  e\ber\brr\brn\bno\bo\n |      POSIX exception code\n |  \n |  f\bfi\bil\ble\ben\bna\bam\bme\be\n |      exception filename\n |  \n |  f\bfi\bil\ble\ben\bna\bam\bme\be2\b2\n |      second exception filename\n |  \n |  s\bst\btr\bre\ber\brr\bro\bor\br\n |      exception strerror\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'OSError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.OSError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'OSError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.OSError' is not a callable object\n"
        },
        {
            "acResult": "ArithmeticError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Base class for arithmetic errors.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class ArithmeticError in \n\n.\b.A\bAr\bri\bit\bth\bhm\bme\bet\bti\bic\bcE\bEr\brr\bro\bor\br = class ArithmeticError(Exception)\n |  Base class for arithmetic errors.\n |  \n |  Method resolution order:\n |      ArithmeticError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      FloatingPointError\n |      OverflowError\n |      ZeroDivisionError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ArithmeticError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.ArithmeticError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ArithmeticError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.ArithmeticError' is not a callable object\n"
        },
        {
            "acResult": "AssertionError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Assertion failed.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class AssertionError in \n\n.\b.A\bAs\bss\bse\ber\brt\bti\bio\bon\bnE\bEr\brr\bro\bor\br = class AssertionError(Exception)\n |  Assertion failed.\n |  \n |  Method resolution order:\n |      AssertionError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'AssertionError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.AssertionError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'AssertionError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.AssertionError' is not a callable object\n"
        },
        {
            "acResult": "AttributeError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Attribute not found.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class AttributeError in \n\n.\b.A\bAt\btt\btr\bri\bib\bbu\but\bte\beE\bEr\brr\bro\bor\br = class AttributeError(Exception)\n |  Attribute not found.\n |  \n |  Method resolution order:\n |      AttributeError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'AttributeError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.AttributeError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'AttributeError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.AttributeError' is not a callable object\n"
        },
        {
            "acResult": "EOFError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Read beyond end of file.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class EOFError in \n\n.\b.E\bEO\bOF\bFE\bEr\brr\bro\bor\br = class EOFError(Exception)\n |  Read beyond end of file.\n |  \n |  Method resolution order:\n |      EOFError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'EOFError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.EOFError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'EOFError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.EOFError' is not a callable object\n"
        },
        {
            "acResult": "ImportError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Import can't find module, or can't find name in module.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class ImportError in \n\n.\b.I\bIm\bmp\bpo\bor\brt\btE\bEr\brr\bro\bor\br = class ImportError(Exception)\n |  Import can't find module, or can't find name in module.\n |  \n |  Method resolution order:\n |      ImportError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      ModuleNotFoundError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  m\bms\bsg\bg\n |      exception message\n |  \n |  n\bna\bam\bme\be\n |      module name\n |  \n |  p\bpa\bat\bth\bh\n |      module path\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from Exception:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ImportError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.ImportError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ImportError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.ImportError' is not a callable object\n"
        },
        {
            "acResult": "LookupError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Base class for lookup errors.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class LookupError in \n\n.\b.L\bLo\boo\bok\bku\bup\bpE\bEr\brr\bro\bor\br = class LookupError(Exception)\n |  Base class for lookup errors.\n |  \n |  Method resolution order:\n |      LookupError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      IndexError\n |      KeyError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'LookupError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.LookupError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'LookupError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.LookupError' is not a callable object\n"
        },
        {
            "acResult": "MemoryError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Out of memory.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class MemoryError in \n\n.\b.M\bMe\bem\bmo\bor\bry\byE\bEr\brr\bro\bor\br = class MemoryError(Exception)\n |  Out of memory.\n |  \n |  Method resolution order:\n |      MemoryError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'MemoryError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.MemoryError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'MemoryError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.MemoryError' is not a callable object\n"
        },
        {
            "acResult": "NameError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Name not found globally.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class NameError in \n\n.\b.N\bNa\bam\bme\beE\bEr\brr\bro\bor\br = class NameError(Exception)\n |  Name not found globally.\n |  \n |  Method resolution order:\n |      NameError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      UnboundLocalError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'NameError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.NameError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'NameError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.NameError' is not a callable object\n"
        },
        {
            "acResult": "RuntimeError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Unspecified run-time error.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class RuntimeError in \n\n.\b.R\bRu\bun\bnt\bti\bim\bme\beE\bEr\brr\bro\bor\br = class RuntimeError(Exception)\n |  Unspecified run-time error.\n |  \n |  Method resolution order:\n |      RuntimeError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      NotImplementedError\n |      RecursionError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'RuntimeError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.RuntimeError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'RuntimeError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.RuntimeError' is not a callable object\n"
        },
        {
            "acResult": "StopAsyncIteration",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Signal the end from iterator.__anext__().",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class StopAsyncIteration in \n\n.\b.S\bSt\bto\bop\bpA\bAs\bsy\byn\bnc\bcI\bIt\bte\ber\bra\bat\bti\bio\bon\bn = class StopAsyncIteration(Exception)\n |  Signal the end from iterator.__anext__().\n |  \n |  Method resolution order:\n |      StopAsyncIteration\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'StopAsyncIteration'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.StopAsyncIteration' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'StopAsyncIteration'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.StopAsyncIteration' is not a callable object\n"
        },
        {
            "acResult": "SyntaxError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Invalid syntax.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class SyntaxError in \n\n.\b.S\bSy\byn\bnt\bta\bax\bxE\bEr\brr\bro\bor\br = class SyntaxError(Exception)\n |  Invalid syntax.\n |  \n |  Method resolution order:\n |      SyntaxError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      IndentationError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  f\bfi\bil\ble\ben\bna\bam\bme\be\n |      exception filename\n |  \n |  l\bli\bin\bne\ben\bno\bo\n |      exception lineno\n |  \n |  m\bms\bsg\bg\n |      exception msg\n |  \n |  o\bof\bff\bfs\bse\bet\bt\n |      exception offset\n |  \n |  p\bpr\bri\bin\bnt\bt_\b_f\bfi\bil\ble\be_\b_a\ban\bnd\bd_\b_l\bli\bin\bne\be\n |      exception print_file_and_line\n |  \n |  t\bte\bex\bxt\bt\n |      exception text\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from Exception:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'SyntaxError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.SyntaxError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'SyntaxError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.SyntaxError' is not a callable object\n"
        },
        {
            "acResult": "TypeError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Inappropriate argument type.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class TypeError in \n\n.\b.T\bTy\byp\bpe\beE\bEr\brr\bro\bor\br = class TypeError(Exception)\n |  Inappropriate argument type.\n |  \n |  Method resolution order:\n |      TypeError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'TypeError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.TypeError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'TypeError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.TypeError' is not a callable object\n"
        },
        {
            "acResult": "ValueError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Inappropriate argument value (of correct type).",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class ValueError in \n\n.\b.V\bVa\bal\blu\bue\beE\bEr\brr\bro\bor\br = class ValueError(Exception)\n |  Inappropriate argument value (of correct type).\n |  \n |  Method resolution order:\n |      ValueError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      UnicodeError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ValueError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.ValueError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ValueError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.ValueError' is not a callable object\n"
        },
        {
            "acResult": "FloatingPointError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Floating point operation failed.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class FloatingPointError in \n\n.\b.F\bFl\blo\boa\bat\bti\bin\bng\bgP\bPo\boi\bin\bnt\btE\bEr\brr\bro\bor\br = class FloatingPointError(ArithmeticError)\n |  Floating point operation failed.\n |  \n |  Method resolution order:\n |      FloatingPointError\n |      ArithmeticError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'FloatingPointError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.FloatingPointError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'FloatingPointError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.FloatingPointError' is not a callable object\n"
        },
        {
            "acResult": "OverflowError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Result too large to be represented.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class OverflowError in \n\n.\b.O\bOv\bve\ber\brf\bfl\blo\bow\bwE\bEr\brr\bro\bor\br = class OverflowError(ArithmeticError)\n |  Result too large to be represented.\n |  \n |  Method resolution order:\n |      OverflowError\n |      ArithmeticError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'OverflowError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.OverflowError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'OverflowError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.OverflowError' is not a callable object\n"
        },
        {
            "acResult": "ZeroDivisionError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Second argument to a division or modulo operation was zero.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class ZeroDivisionError in \n\n.\b.Z\bZe\ber\bro\boD\bDi\biv\bvi\bis\bsi\bio\bon\bnE\bEr\brr\bro\bor\br = class ZeroDivisionError(ArithmeticError)\n |  Second argument to a division or modulo operation was zero.\n |  \n |  Method resolution order:\n |      ZeroDivisionError\n |      ArithmeticError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ZeroDivisionError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.ZeroDivisionError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'ZeroDivisionError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.ZeroDivisionError' is not a callable object\n"
        },
        {
            "acResult": "IndexError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Sequence index out of range.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class IndexError in \n\n.\b.I\bIn\bnd\bde\bex\bxE\bEr\brr\bro\bor\br = class IndexError(LookupError)\n |  Sequence index out of range.\n |  \n |  Method resolution order:\n |      IndexError\n |      LookupError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'IndexError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.IndexError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'IndexError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.IndexError' is not a callable object\n"
        },
        {
            "acResult": "KeyError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Mapping key not found.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class KeyError in \n\n.\b.K\bKe\bey\byE\bEr\brr\bro\bor\br = class KeyError(LookupError)\n |  Mapping key not found.\n |  \n |  Method resolution order:\n |      KeyError\n |      LookupError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from LookupError:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'KeyError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.KeyError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'KeyError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.KeyError' is not a callable object\n"
        },
        {
            "acResult": "NotImplementedError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Method or function hasn't been implemented yet.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class NotImplementedError in \n\n.\b.N\bNo\bot\btI\bIm\bmp\bpl\ble\bem\bme\ben\bnt\bte\bed\bdE\bEr\brr\bro\bor\br = class NotImplementedError(RuntimeError)\n |  Method or function hasn't been implemented yet.\n |  \n |  Method resolution order:\n |      NotImplementedError\n |      RuntimeError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'NotImplementedError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.NotImplementedError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'NotImplementedError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.NotImplementedError' is not a callable object\n"
        },
        {
            "acResult": "IndentationError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Improper indentation.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class IndentationError in \n\n.\b.I\bIn\bnd\bde\ben\bnt\bta\bat\bti\bio\bon\bnE\bEr\brr\bro\bor\br = class IndentationError(SyntaxError)\n |  Improper indentation.\n |  \n |  Method resolution order:\n |      IndentationError\n |      SyntaxError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Built-in subclasses:\n |      TabError\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from SyntaxError:\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from SyntaxError:\n |  \n |  f\bfi\bil\ble\ben\bna\bam\bme\be\n |      exception filename\n |  \n |  l\bli\bin\bne\ben\bno\bo\n |      exception lineno\n |  \n |  m\bms\bsg\bg\n |      exception msg\n |  \n |  o\bof\bff\bfs\bse\bet\bt\n |      exception offset\n |  \n |  p\bpr\bri\bin\bnt\bt_\b_f\bfi\bil\ble\be_\b_a\ban\bnd\bd_\b_l\bli\bin\bne\be\n |      exception print_file_and_line\n |  \n |  t\bte\bex\bxt\bt\n |      exception text\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from Exception:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'IndentationError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.IndentationError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'IndentationError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.IndentationError' is not a callable object\n"
        },
        {
            "acResult": "TabError",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Improper mixture of spaces and tabs.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class TabError in \n\n.\b.T\bTa\bab\bbE\bEr\brr\bro\bor\br = class TabError(IndentationError)\n |  Improper mixture of spaces and tabs.\n |  \n |  Method resolution order:\n |      TabError\n |      IndentationError\n |      SyntaxError\n |      Exception\n |      BaseException\n |      object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from SyntaxError:\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from SyntaxError:\n |  \n |  f\bfi\bil\ble\ben\bna\bam\bme\be\n |      exception filename\n |  \n |  l\bli\bin\bne\ben\bno\bo\n |      exception lineno\n |  \n |  m\bms\bsg\bg\n |      exception msg\n |  \n |  o\bof\bff\bfs\bse\bet\bt\n |      exception offset\n |  \n |  p\bpr\bri\bin\bnt\bt_\b_f\bfi\bil\ble\be_\b_a\ban\bnd\bd_\b_l\bli\bin\bne\be\n |      exception print_file_and_line\n |  \n |  t\bte\bex\bxt\bt\n |      exception text\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from Exception:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from BaseException:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  _\b__\b_s\bse\bet\bts\bst\bta\bat\bte\be_\b__\b_(...)\n |  \n |  w\bwi\bit\bth\bh_\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk(...)\n |      Exception.with_traceback(tb) --\n |      set self.__traceback__ to tb and return self.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors inherited from BaseException:\n |  \n |  _\b__\b_c\bca\bau\bus\bse\be_\b__\b_\n |      exception cause\n |  \n |  _\b__\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |      exception context\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  _\b__\b_s\bsu\bup\bpp\bpr\bre\bes\bss\bs_\b_c\bco\bon\bnt\bte\bex\bxt\bt_\b__\b_\n |  \n |  _\b__\b_t\btr\bra\bac\bce\beb\bba\bac\bck\bk_\b__\b_\n |  \n |  a\bar\brg\bgs\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'TabError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'.TabError' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'TabError'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: '.TabError' is not a callable object\n"
        }
    ],
    "uarray": [],
    "utime": [],
    "speech": [
        {
            "acResult": "translate",
            "type": [
                "function"
            ],
            "documentation": "Translate English words to phonemes.\n\nExample: ``speech.translate('hello world')``\n\n:param words: A string of English words.\n:return: A string containing a best guess at the appropriate phonemes to pronounce.\nThe output is generated from this `text to phoneme translation table <https://github.com/s-macke/SAM/wiki/Text-to-phoneme-translation-table>`_.\n\nThis function should be used to generate a first approximation of phonemes\nthat can be further hand-edited to improve accuracy, inflection and\nemphasis.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.",
            "version": 0,
            "params": [
                {
                    "name": "words"
                }
            ]
        },
        {
            "acResult": "pronounce",
            "type": [
                "function"
            ],
            "documentation": "Pronounce phonemes.\n\nExample: ``speech.pronounce(' /HEHLOW WERLD')``\n\n:param phonemes: The string of phonemes to pronounce\n:param pitch: A number representing the pitch of the voice\n:param speed: A number representing the speed of the voice\n:param mouth: A number representing the mouth of the voice\n:param throat: A number representing the throat of the voice\n:param pin: Optional argument to specify the output pin can be used to override the default of ``pin0``.\nIf we do not want any sound to play out of the pins can use ``pin=None``. micro:bit V2 only.\n\nOverride the optional pitch, speed, mouth and throat settings to change the\ntimbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.",
            "version": 0,
            "params": [
                {
                    "name": "phonemes"
                },
                {
                    "name": "pitch"
                },
                {
                    "name": "speed",
                    "defaultValue": "128"
                },
                {
                    "name": "mouth",
                    "defaultValue": "128"
                },
                {
                    "name": "throat",
                    "defaultValue": "72"
                },
                {
                    "name": "pin",
                    "defaultValue": "64"
                }
            ]
        },
        {
            "acResult": "say",
            "type": [
                "function"
            ],
            "documentation": "Say English words.\n\nExample: ``speech.say('hello world')``\n\n:param words: The string of words to say.\n:param pitch: A number representing the pitch of the voice\n:param speed: A number representing the speed of the voice\n:param mouth: A number representing the mouth of the voice\n:param throat: A number representing the throat of the voice\n:param pin: Optional argument to specify the output pin can be used to override the default of ``pin0``.\nIf we do not want any sound to play out of the pins can use ``pin=None``. micro:bit V2 only.\n\nThe result is semi-accurate for English. Override the optional pitch, speed,\nmouth and throat settings to change the timbre (quality) of the voice.\n\nThis is a short-hand equivalent of:\n``speech.pronounce(speech.translate(words))``\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.",
            "version": 0,
            "params": [
                {
                    "name": "words"
                },
                {
                    "name": "pitch"
                },
                {
                    "name": "speed",
                    "defaultValue": "128"
                },
                {
                    "name": "mouth",
                    "defaultValue": "128"
                },
                {
                    "name": "throat",
                    "defaultValue": "72"
                },
                {
                    "name": "pin",
                    "defaultValue": "64"
                }
            ]
        },
        {
            "acResult": "sing",
            "type": [
                "function"
            ],
            "documentation": "Sing phonemes.\n\nExample: ``speech.sing(' /HEHLOW WERLD')``\n\n:param phonemes: The string of words to sing.\n:param pitch: A number representing the pitch of the voice\n:param speed: A number representing the speed of the voice\n:param mouth: A number representing the mouth of the voice\n:param throat: A number representing the throat of the voice\n:param pin: Optional argument to specify the output pin can be used to override the default of ``pin0``.\nIf we do not want any sound to play out of the pins can use ``pin=None``. micro:bit V2 only.\n\nOverride the optional pitch, speed, mouth and throat settings to change\nthe timbre (quality) of the voice.\n\nSee `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/speech.html>`_ for detailed information.",
            "version": 0,
            "params": [
                {
                    "name": "phonemes"
                },
                {
                    "name": "pitch"
                },
                {
                    "name": "speed",
                    "defaultValue": "128"
                },
                {
                    "name": "mouth",
                    "defaultValue": "128"
                },
                {
                    "name": "throat",
                    "defaultValue": "72"
                },
                {
                    "name": "pin",
                    "defaultValue": "64"
                }
            ]
        }
    ],
    "_typeshed": [
        {
            "acResult": "IdentityFunction",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsLessThan",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsDivMod",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsRDivMod",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsLenAndGetItem",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsItems",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsKeysAndGetItem",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsGetItem",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsItemAccess",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "HasFileno",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsRead",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsReadline",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsNoArgReadline",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsWrite",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "NoneType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        }
    ],
    "this": [
        {
            "acResult": "authors",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0
        }
    ],
    "typing_extensions": [
        {
            "acResult": "_SpecialForm",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "runtime_checkable",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "cls"
                }
            ]
        },
        {
            "acResult": "Protocol",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "Final",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "final",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "f"
                }
            ]
        },
        {
            "acResult": "Literal",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "IntVar",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "name"
                }
            ]
        },
        {
            "acResult": "_TypedDict",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "TypedDict",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "get_type_hints",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                },
                {
                    "name": "globalns",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "localns",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "include_extras",
                    "defaultValue": "Ellipsis"
                }
            ]
        },
        {
            "acResult": "get_args",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "tp"
                }
            ]
        },
        {
            "acResult": "get_origin",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "tp"
                }
            ]
        },
        {
            "acResult": "Annotated",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "_AnnotatedAlias",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "SupportsIndex",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "ParamSpecArgs",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "ParamSpecKwargs",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "ParamSpec",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "Concatenate",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "TypeAlias",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "TypeGuard",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        }
    ],
    "love": [
        {
            "acResult": "badaboom",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0
        }
    ],
    "microbit.audio": [
        {
            "acResult": "play",
            "type": [
                "function"
            ],
            "documentation": "Play a built-in sound, sound effect or custom audio frames.\n\nExample: ``audio.play(Sound.GIGGLE)``\n\n:param source: A built-in ``Sound`` such as ``Sound.GIGGLE``, a ``SoundEffect`` or sample data as an iterable of ``AudioFrame`` objects.\n:param wait: If ``wait`` is ``True``, this function will block until the sound is complete.\n:param pin: An optional argument to specify the output pin can be used to  override the default of ``pin0``. If we do not want any sound to play we can use ``pin=None``.\n:param return_pin: Specifies a differential edge connector pin to connect to an external speaker instead of ground. This is ignored for the **V2** revision.",
            "version": 0,
            "params": [
                {
                    "name": "source"
                },
                {
                    "name": "wait",
                    "defaultValue": "None"
                },
                {
                    "name": "pin"
                },
                {
                    "name": "return_pin",
                    "defaultValue": "True"
                }
            ]
        },
        {
            "acResult": "is_playing",
            "type": [
                "function"
            ],
            "documentation": "Check whether a sound is playing.\n\nExample: ``audio.is_playing()``\n\n:return: ``True`` if audio is playing, otherwise ``False``.",
            "version": 0
        },
        {
            "acResult": "stop",
            "type": [
                "function"
            ],
            "documentation": "Stop all audio playback.\n\nExample: ``audio.stop()``",
            "version": 0
        },
        {
            "acResult": "SoundEffect",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A sound effect, composed by a set of parameters configured via the constructor or attributes.",
            "version": 0
        },
        {
            "acResult": "AudioFrame",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ``AudioFrame`` object is a list of 32 samples each of which is a unsigned byte\n(whole number between 0 and 255).\n\nIt takes just over 4 ms to play a single frame.\n\nExample::\n\n    frame = AudioFrame()\n    for i in range(len(frame)):\n        frame[i] = 252 - i * 8",
            "version": 0
        }
    ],
    "microbit.display": [
        {
            "acResult": "get_pixel",
            "type": [
                "function"
            ],
            "documentation": "Get the brightness of the LED at column ``x`` and row ``y``.\n\nExample: ``display.get_pixel(0, 0)``\n\n:param x: The display column (0..4)\n:param y: The display row (0..4)\n:return: A number between 0 (off) and 9 (bright)",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "y"
                }
            ]
        },
        {
            "acResult": "set_pixel",
            "type": [
                "function"
            ],
            "documentation": "Set the brightness of the LED at column ``x`` and row ``y``.\n\nExample: ``display.set_pixel(0, 0, 9)``\n\n:param x: The display column (0..4)\n:param y: The display row (0..4)\n:param value: The brightness between 0 (off) and 9 (bright)",
            "version": 0,
            "params": [
                {
                    "name": "x"
                },
                {
                    "name": "y"
                },
                {
                    "name": "value"
                }
            ]
        },
        {
            "acResult": "clear",
            "type": [
                "function"
            ],
            "documentation": "Set the brightness of all LEDs to 0 (off).\n\nExample: ``display.clear()``",
            "version": 0
        },
        {
            "acResult": "show",
            "type": [
                "function"
            ],
            "documentation": "Shows images, letters or digits on the LED display.\n\nExample: ``display.show(Image.HEART)``\n\nWhen ``image`` is an image or a list of images then each image is displayed in turn.\nIf ``image`` is a string or number, each letter or digit is displayed in turn.\n\n:param image: A string, number, image or list of images to show.\n:param delay: Each letter, digit or image is shown with ``delay`` milliseconds between them.\n:param wait: If ``wait`` is ``True``, this function will block until the animation is finished, otherwise the animation will happen in the background.\n:param loop: If ``loop`` is ``True``, the animation will repeat forever.\n:param clear: If ``clear`` is ``True``, the display will be cleared after the sequence has finished.\n\nThe ``wait``, ``loop`` and ``clear`` arguments must be specified using their keyword.",
            "version": 0,
            "params": [
                {
                    "name": "image"
                },
                {
                    "name": "delay",
                    "defaultValue": "False"
                },
                {
                    "name": "wait",
                    "defaultValue": "False"
                },
                {
                    "name": "loop",
                    "defaultValue": "True"
                },
                {
                    "name": "clear",
                    "defaultValue": "400"
                }
            ]
        },
        {
            "acResult": "scroll",
            "type": [
                "function"
            ],
            "documentation": "Scrolls a number or text on the LED display.\n\nExample: ``display.scroll('micro:bit')``\n\n:param text: The string to scroll. If ``text`` is an integer or float it is first converted to a string using ``str()``.\n:param delay: The ``delay`` parameter controls how fast the text is scrolling.\n:param wait: If ``wait`` is ``True``, this function will block until the animation is finished, otherwise the animation will happen in the background.\n:param loop: If ``loop`` is ``True``, the animation will repeat forever.\n:param monospace: If ``monospace`` is ``True``, the characters will all take up 5 pixel-columns in width, otherwise there will be exactly 1 blank pixel-column between each character as they scroll.\n\nThe ``wait``, ``loop`` and ``monospace`` arguments must be specified\nusing their keyword.",
            "version": 0,
            "params": [
                {
                    "name": "text"
                },
                {
                    "name": "delay",
                    "defaultValue": "False"
                },
                {
                    "name": "wait",
                    "defaultValue": "False"
                },
                {
                    "name": "loop",
                    "defaultValue": "True"
                },
                {
                    "name": "monospace",
                    "defaultValue": "150"
                }
            ]
        },
        {
            "acResult": "on",
            "type": [
                "function"
            ],
            "documentation": "Turn on the LED display.\n\nExample: ``display.on()``",
            "version": 0
        },
        {
            "acResult": "off",
            "type": [
                "function"
            ],
            "documentation": "Turn off the LED display (disabling the display allows you to re-use the GPIO pins for other purposes).\n\nExample: ``display.off()``",
            "version": 0
        },
        {
            "acResult": "is_on",
            "type": [
                "function"
            ],
            "documentation": "Check whether the LED display is enabled.\n\nExample: ``display.is_on()``\n\n:return: ``True`` if the display is on, otherwise returns ``False``.",
            "version": 0
        },
        {
            "acResult": "read_light_level",
            "type": [
                "function"
            ],
            "documentation": "Read the light level.\n\nExample: ``display.read_light_level()``\n\nUses the display's LEDs in reverse-bias mode to sense the amount of light\nfalling on the display.\n\n:return: An integer between 0 and 255 representing the light level, with larger meaning more light.",
            "version": 0
        }
    ],
    "microbit": [
        {
            "acResult": "accelerometer",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "audio",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "compass",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "display",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "i2c",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "microphone",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "speaker",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "spi",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "uart",
            "type": [
                "module"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "run_every",
            "type": [
                "function"
            ],
            "documentation": "Schedule to run a function at the interval specified by the time arguments **V2 only**.\n\nExample: ``run_every(my_logging, min=5)``\n\n``run_every`` can be used in two ways:\n\nAs a Decorator - placed on top of the function to schedule. For example::\n\n    @run_every(h=1, min=20, s=30, ms=50)\n    def my_function():\n        # Do something here\n\nAs a Function - passing the callback as a positional argument. For example::\n\n    def my_function():\n        # Do something here\n    run_every(my_function, s=30)\n\nEach argument corresponds to a different time unit and they are additive.\nSo ``run_every(min=1, s=30)`` schedules the callback every minute and a half.\n\nWhen an exception is thrown inside the callback function it deschedules the\nfunction. To avoid this you can catch exceptions with ``try/except``.\n\n:param callback: Function to call at the provided interval. Omit when using as a decorator.\n:param days: Sets the day mark for the scheduling.\n:param h: Sets the hour mark for the scheduling.\n:param min: Sets the minute mark for the scheduling.\n:param s: Sets the second mark for the scheduling.\n:param ms: Sets the millisecond mark for the scheduling.",
            "version": 0,
            "params": [
                {
                    "name": "callback",
                    "defaultValue": "0"
                },
                {
                    "name": "days",
                    "defaultValue": "0"
                },
                {
                    "name": "h",
                    "defaultValue": "0"
                },
                {
                    "name": "min",
                    "defaultValue": "0"
                },
                {
                    "name": "s",
                    "defaultValue": "0"
                },
                {
                    "name": "ms",
                    "defaultValue": "None"
                }
            ]
        },
        {
            "acResult": "panic",
            "type": [
                "function"
            ],
            "documentation": "Enter a panic mode.\n\nExample: ``panic(127)``\n\n:param n: An arbitrary integer <= 255 to indicate a status.\n\nRequires restart.",
            "version": 0,
            "params": [
                {
                    "name": "n"
                }
            ]
        },
        {
            "acResult": "reset",
            "type": [
                "function"
            ],
            "documentation": "Restart the board.",
            "version": 0
        },
        {
            "acResult": "scale",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Converts a value from a range to an integer range.\n\nExample: ``volume = scale(accelerometer.get_x(), from_=(-2000, 2000), to=(0, 255))``\n\nFor example, to convert an accelerometer X value to a speaker volume.\n\nIf one of the numbers in the ``to`` parameter is a floating point\n(i.e a decimal number like ``10.0``), this function will return a\nfloating point number.\n\n    temp_fahrenheit = scale(30, from_=(0.0, 100.0), to=(32.0, 212.0))\n\n:param value: A number to convert.\n:param from_: A tuple to define the range to convert from.\n:param to: A tuple to define the range to convert to.\n:return: The ``value`` converted to the ``to`` range.",
            "version": 0,
            "params": [
                {
                    "name": "value"
                },
                {
                    "name": "from_"
                },
                {
                    "name": "to"
                }
            ]
        },
        {
            "acResult": "sleep",
            "type": [
                "function"
            ],
            "documentation": "Wait for ``n`` milliseconds.\n\nExample: ``sleep(1000)``\n\n:param n: The number of milliseconds to wait\n\nOne second is 1000 milliseconds, so::\n\n    microbit.sleep(1000)\n\nwill pause the execution for one second.",
            "version": 0,
            "params": [
                {
                    "name": "n"
                }
            ]
        },
        {
            "acResult": "running_time",
            "type": [
                "function"
            ],
            "documentation": "Get the running time of the board.\n\n:return: The number of milliseconds since the board was switched on or restarted.",
            "version": 0
        },
        {
            "acResult": "temperature",
            "type": [
                "function"
            ],
            "documentation": "Get the temperature of the micro:bit in degrees Celsius.",
            "version": 0
        },
        {
            "acResult": "set_volume",
            "type": [
                "function"
            ],
            "documentation": "Sets the volume.\n\nExample: ``set_volume(127)``\n\n:param v: a value between 0 (low) and 255 (high).\n\nOut of range values will be clamped to 0 or 255.\n\n**V2** only.",
            "version": 0,
            "params": [
                {
                    "name": "v"
                }
            ]
        },
        {
            "acResult": "Button",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The class for the buttons ``button_a`` and ``button_b``.",
            "version": 0
        },
        {
            "acResult": "button_a",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "button_b",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "MicroBitDigitalPin",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A digital pin.\n\nSome pins support analog and touch features using the ``MicroBitAnalogDigitalPin`` and ``MicroBitTouchPin`` subclasses.",
            "version": 0
        },
        {
            "acResult": "MicroBitAnalogDigitalPin",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A pin with analog and digital features.",
            "version": 0
        },
        {
            "acResult": "MicroBitTouchPin",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A pin with analog, digital and touch features.",
            "version": 0
        },
        {
            "acResult": "pin0",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin1",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin2",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin3",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin4",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin5",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin6",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin7",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin8",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin9",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin10",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin11",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin12",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin13",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin14",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin15",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin16",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin19",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin20",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin_logo",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "pin_speaker",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "Image",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An image to show on the micro:bit LED display.\n\nGiven an image object it's possible to display it via the ``display`` API::\n\n    display.show(Image.HAPPY)",
            "version": 0
        },
        {
            "acResult": "SoundEvent",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "Sound",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The built-in sounds can be called using ``audio.play(Sound.NAME)``.",
            "version": 0
        },
        {
            "acResult": "__doc__",
            "type": [
                "module"
            ],
            "documentation": "Pins, images, sounds, temperature and volume.",
            "version": 0
        }
    ],
    "microbit.speaker": [
        {
            "acResult": "off",
            "type": [
                "function"
            ],
            "documentation": "Turn the speaker off.\n\nExample: ``speaker.off()``\n\nThis does not disable sound output to an edge connector pin.",
            "version": 0
        },
        {
            "acResult": "on",
            "type": [
                "function"
            ],
            "documentation": "Turn the speaker on.\n\nExample: ``speaker.on()``",
            "version": 0
        }
    ],
    "microbit.i2c": [
        {
            "acResult": "init",
            "type": [
                "function"
            ],
            "documentation": "Re-initialize a peripheral.\n\nExample: ``i2c.init()``\n\n:param freq: clock frequency\n:param sda: ``sda`` pin (default 20)\n:param scl: ``scl`` pin (default 19)\n\nOn a micro:bit V1 board, changing the I\u00b2C pins from defaults will make\nthe accelerometer and compass stop working, as they are connected\ninternally to those pins. This warning does not apply to the **V2**\nrevision of the micro:bit as this has `separate I\u00b2C lines <https://tech.microbit.org/hardware/i2c/>`_\nfor the motion sensors and the edge connector.",
            "version": 0,
            "params": [
                {
                    "name": "freq"
                },
                {
                    "name": "sda"
                },
                {
                    "name": "scl",
                    "defaultValue": "100000"
                }
            ]
        },
        {
            "acResult": "scan",
            "type": [
                "function"
            ],
            "documentation": "Scan the bus for devices.\n\nExample: ``i2c.scan()``\n\n:return: A list of 7-bit addresses corresponding to those devices that responded to the scan.",
            "version": 0
        },
        {
            "acResult": "read",
            "type": [
                "function"
            ],
            "documentation": "Read bytes from a device.\n\nExample: ``i2c.read(0x50, 64)``\n\n:param addr: The 7-bit address of the device\n:param n: The number of bytes to read\n:param repeat: If ``True``, no stop bit will be sent\n:return: The bytes read",
            "version": 0,
            "params": [
                {
                    "name": "addr"
                },
                {
                    "name": "n"
                },
                {
                    "name": "repeat",
                    "defaultValue": "False"
                }
            ]
        },
        {
            "acResult": "write",
            "type": [
                "function"
            ],
            "documentation": "Write bytes to a device.\n\nExample: ``i2c.write(0x50, bytes([1, 2, 3]))``\n\n:param addr: The 7-bit address of the device\n:param buf: A buffer containing the bytes to write\n:param repeat: If ``True``, no stop bit will be sent",
            "version": 0,
            "params": [
                {
                    "name": "addr"
                },
                {
                    "name": "buf"
                },
                {
                    "name": "repeat",
                    "defaultValue": "False"
                }
            ]
        }
    ],
    "microbit.compass": [
        {
            "acResult": "calibrate",
            "type": [
                "function"
            ],
            "documentation": "Starts the calibration process.\n\nExample: ``compass.calibrate()``\n\nAn instructive message will be scrolled to the user after which they will need\nto rotate the device in order to draw a circle on the LED display.",
            "version": 0
        },
        {
            "acResult": "is_calibrated",
            "type": [
                "function"
            ],
            "documentation": "Check is the compass is calibrated.\n\nExample: ``compass.is_calibrated()``\n\n:return: ``True`` if the compass has been successfully calibrated, ``False`` otherwise.",
            "version": 0
        },
        {
            "acResult": "clear_calibration",
            "type": [
                "function"
            ],
            "documentation": "Undoes the calibration, making the compass uncalibrated again.\n\nExample: ``compass.clear_calibration()``",
            "version": 0
        },
        {
            "acResult": "get_x",
            "type": [
                "function"
            ],
            "documentation": "Get the magnetic field strength on the ``x`` axis.\n\nExample: ``compass.get_x()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.",
            "version": 0
        },
        {
            "acResult": "get_y",
            "type": [
                "function"
            ],
            "documentation": "Get the magnetic field strength on the ``y`` axis.\n\nExample: ``compass.get_y()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.",
            "version": 0
        },
        {
            "acResult": "get_z",
            "type": [
                "function"
            ],
            "documentation": "Get the magnetic field strength on the ``z`` axis.\n\nExample: ``compass.get_z()``\n\nCall ``calibrate`` first or the results will be inaccurate.\n\n:return: A positive or negative integer in nano tesla representing the magnitude and direction of the field.",
            "version": 0
        },
        {
            "acResult": "heading",
            "type": [
                "function"
            ],
            "documentation": "Get the compass heading.\n\nExample: ``compass.heading()``\n\n:return: An integer in the range from 0 to 360, representing the angle in degrees, clockwise, with north as 0.",
            "version": 0
        },
        {
            "acResult": "get_field_strength",
            "type": [
                "function"
            ],
            "documentation": "Get the magnitude of the magnetic field around the device.\n\nExample: ``compass.get_field_strength()``\n\n:return: An integer indication of the magnitude of the magnetic field in nano tesla.",
            "version": 0
        }
    ],
    "microbit.uart": [
        {
            "acResult": "ODD",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "EVEN",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "init",
            "type": [
                "function"
            ],
            "documentation": "Initialize serial communication.\n\nExample: ``uart.init(115200, tx=pin0, rx=pin1)``\n\n:param baudrate: The speed of communication.\n:param bits: The size of bytes being transmitted. micro:bit only supports 8.\n:param parity: How parity is checked, ``None``, ``uart.ODD`` or ``uart.EVEN``.\n:param stop: The number of stop bits, has to be 1 for micro:bit.\n:param tx: Transmitting pin.\n:param rx: Receiving pin.\n\nInitializing the UART on external pins will cause the Python console on\nUSB to become unaccessible, as it uses the same hardware. To bring the\nconsole back you must reinitialize the UART without passing anything for\n``tx`` or ``rx`` (or passing ``None`` to these arguments).  This means\nthat calling ``uart.init(115200)`` is enough to restore the Python console.\n\nFor more details see `the online documentation <https://microbit-micropython.readthedocs.io/en/v2-docs/uart.html>`_.",
            "version": 0,
            "params": [
                {
                    "name": "baudrate",
                    "defaultValue": "None"
                },
                {
                    "name": "bits",
                    "defaultValue": "None"
                },
                {
                    "name": "parity",
                    "defaultValue": "1"
                },
                {
                    "name": "stop",
                    "defaultValue": "None"
                },
                {
                    "name": "tx",
                    "defaultValue": "8"
                },
                {
                    "name": "rx",
                    "defaultValue": "9600"
                }
            ]
        },
        {
            "acResult": "any",
            "type": [
                "function"
            ],
            "documentation": "Check if any data is waiting.\n\nExample: ``uart.any()``\n\n:return: ``True`` if any data is waiting, else ``False``.",
            "version": 0
        },
        {
            "acResult": "read",
            "type": [
                "function"
            ],
            "documentation": "Read bytes.\n\nExample: ``uart.read()``\n\n:param nbytes: If ``nbytes`` is specified then read at most that many bytes, otherwise read as many bytes as possible\n:return: A bytes object or ``None`` on timeout",
            "version": 0,
            "params": [
                {
                    "name": "nbytes",
                    "defaultValue": "None"
                }
            ]
        },
        {
            "acResult": "readinto",
            "type": [
                "function"
            ],
            "documentation": "Read bytes into the ``buf``.\n\nExample: ``uart.readinto(input_buffer)``\n\n:param buf: The buffer to write to.\n:param nbytes: If ``nbytes`` is specified then read at most that many bytes, otherwise read ``len(buf)`` bytes.\n:return: number of bytes read and stored into ``buf`` or ``None`` on timeout.",
            "version": 0,
            "params": [
                {
                    "name": "buf"
                },
                {
                    "name": "nbytes",
                    "defaultValue": "None"
                }
            ]
        },
        {
            "acResult": "readline",
            "type": [
                "function"
            ],
            "documentation": "Read a line, ending in a newline character.\n\nExample: ``uart.readline()``\n\n:return: The line read or ``None`` on timeout. The newline character is included in the returned bytes.",
            "version": 0
        },
        {
            "acResult": "write",
            "type": [
                "function"
            ],
            "documentation": "Write a buffer to the bus.\n\nExample: ``uart.write('hello world')``\n\n:param buf: A bytes object or a string.\n:return: The number of bytes written, or ``None`` on timeout.\n\nExamples::\n\n    uart.write('hello world')\n    uart.write(b'hello world')\n    uart.write(bytes([1, 2, 3]))",
            "version": 0,
            "params": [
                {
                    "name": "buf"
                }
            ]
        }
    ],
    "microbit.spi": [
        {
            "acResult": "init",
            "type": [
                "function"
            ],
            "documentation": "Initialize SPI communication.\n\nExample: ``spi.init()``\n\nFor correct communication, the parameters have to be the same on both communicating devices.\n\n:param baudrate: The speed of communication.\n:param bits: The width in bits of each transfer. Currently only ``bits=8`` is supported. However, this may change in the future.\n:param mode: Determines the combination of clock polarity and phase - `see online table <https://microbit-micropython.readthedocs.io/en/v2-docs/spi.html#microbit.spi.init>`_.\n:param sclk: sclk pin (default 13)\n:param mosi: mosi pin (default 15)\n:param miso: miso pin (default 14)",
            "version": 0,
            "params": [
                {
                    "name": "baudrate"
                },
                {
                    "name": "bits"
                },
                {
                    "name": "mode"
                },
                {
                    "name": "sclk",
                    "defaultValue": "0"
                },
                {
                    "name": "mosi",
                    "defaultValue": "8"
                },
                {
                    "name": "miso",
                    "defaultValue": "1000000"
                }
            ]
        },
        {
            "acResult": "read",
            "type": [
                "function"
            ],
            "documentation": "Read at most ``nbytes`` while continuously writing the single byte given by ``out``.\n\nExample: ``spi.read(64)``\n\n:param nbytes: Maximum number of bytes to read.\n:param out: The byte value to write (default 0).\n:return: The bytes read.",
            "version": 0,
            "params": [
                {
                    "name": "nbytes"
                },
                {
                    "name": "out",
                    "defaultValue": "0"
                }
            ]
        },
        {
            "acResult": "write",
            "type": [
                "function"
            ],
            "documentation": "Write bytes to the bus.\n\nExample: ``spi.write(bytes([1, 2, 3]))``\n\n:param buffer: A buffer to read data from.",
            "version": 0,
            "params": [
                {
                    "name": "buffer"
                }
            ]
        },
        {
            "acResult": "write_readinto",
            "type": [
                "function"
            ],
            "documentation": "Write the ``out`` buffer to the bus and read any response into the ``in_`` buffer.\n\nExample: ``spi.write_readinto(out_buffer, in_buffer)``\n\nThe length of the buffers should be the same. The buffers can be the same object.\n\n:param out: The buffer to write any response to.\n:param in_: The buffer to read data from.",
            "version": 0,
            "params": [
                {
                    "name": "out"
                },
                {
                    "name": "in_"
                }
            ]
        }
    ],
    "microbit.accelerometer": [
        {
            "acResult": "get_x",
            "type": [
                "function"
            ],
            "documentation": "Get the acceleration measurement in the ``x`` axis in milli-g.\n\nExample: ``accelerometer.get_x()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.",
            "version": 0
        },
        {
            "acResult": "get_y",
            "type": [
                "function"
            ],
            "documentation": "Get the acceleration measurement in the ``y`` axis in milli-g.\n\nExample: ``accelerometer.get_y()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.",
            "version": 0
        },
        {
            "acResult": "get_z",
            "type": [
                "function"
            ],
            "documentation": "Get the acceleration measurement in the ``z`` axis in milli-g.\n\nExample: ``accelerometer.get_z()``\n\n:return: A positive or negative integer depending on direction in the range +/- 2000mg.",
            "version": 0
        },
        {
            "acResult": "get_values",
            "type": [
                "function"
            ],
            "documentation": "Get the acceleration measurements in all axes at once as a tuple.\n\nExample: ``x, y, z = accelerometer.get_values()``\n\n:return: a three-element tuple of integers ordered as X, Y, Z, each value a positive or negative integer depending on direction in the range +/- 2000mg",
            "version": 0
        },
        {
            "acResult": "get_strength",
            "type": [
                "function"
            ],
            "documentation": "Get the acceleration measurement of all axes combined, as a positive integer. This is the Pythagorean sum of the X, Y and Z axes.\n\nExample: ``accelerometer.get_strength()``\n\n:return: The combined acceleration strength of all the axes, in milli-g.",
            "version": 0
        },
        {
            "acResult": "current_gesture",
            "type": [
                "function"
            ],
            "documentation": "Get the name of the current gesture.\n\nExample: ``accelerometer.current_gesture()``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:return: The current gesture",
            "version": 0
        },
        {
            "acResult": "is_gesture",
            "type": [
                "function"
            ],
            "documentation": "Check if the named gesture is currently active.\n\nExample: ``accelerometer.is_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: The gesture name.\n:return: ``True`` if the gesture is active, ``False`` otherwise.",
            "version": 0,
            "params": [
                {
                    "name": "name"
                }
            ]
        },
        {
            "acResult": "was_gesture",
            "type": [
                "function"
            ],
            "documentation": "Check if the named gesture was active since the last call.\n\nExample: ``accelerometer.was_gesture('shake')``\n\nMicroPython understands the following gesture names: ``\"up\"``, ``\"down\"``,\n``\"left\"``, ``\"right\"``, ``\"face up\"``, ``\"face down\"``, ``\"freefall\"``,\n``\"3g\"``, ``\"6g\"``, ``\"8g\"``, ``\"shake\"``. Gestures are always\nrepresented as strings.\n\n:param name: The gesture name.\n:return: ``True`` if the gesture was active since the last call, ``False`` otherwise.",
            "version": 0,
            "params": [
                {
                    "name": "name"
                }
            ]
        },
        {
            "acResult": "get_gestures",
            "type": [
                "function"
            ],
            "documentation": "Return a tuple of the gesture history.\n\nExample: ``accelerometer.get_gestures()``\n\nClears the gesture history before returning.\n\nGestures are not updated in the background so there needs to be constant\ncalls to some accelerometer method to do the gesture detection. Usually\ngestures can be detected using a loop with a small :func:`microbit.sleep` delay.\n\n:return: The history as a tuple, most recent last.",
            "version": 0
        },
        {
            "acResult": "set_range",
            "type": [
                "function"
            ],
            "documentation": "Set the accelerometer sensitivity range, in g (standard gravity), to the closest values supported by the hardware, so it rounds to either ``2``, ``4``, or ``8`` g.\n\nExample: ``accelerometer.set_range(8)``\n\n:param value: New range for the accelerometer, an integer in ``g``.",
            "version": 0,
            "params": [
                {
                    "name": "value"
                }
            ]
        }
    ],
    "microbit.microphone": [
        {
            "acResult": "current_event",
            "type": [
                "function"
            ],
            "documentation": "Get the last recorded sound event\n\nExample: ``microphone.current_event()``\n\n:return: The event, ``SoundEvent('loud')`` or ``SoundEvent('quiet')``.",
            "version": 0
        },
        {
            "acResult": "was_event",
            "type": [
                "function"
            ],
            "documentation": "Check if a sound was heard at least once since the last call.\n\nExample: ``microphone.was_event(SoundEvent.LOUD)``\n\nThis call clears the sound history before returning.\n\n:param event: The event to check for,  such as ``SoundEvent.LOUD`` or ``SoundEvent.QUIET``\n:return: ``True`` if sound was heard at least once since the last call, otherwise ``False``.",
            "version": 0,
            "params": [
                {
                    "name": "event"
                }
            ]
        },
        {
            "acResult": "is_event",
            "type": [
                "function"
            ],
            "documentation": "Check the most recent sound event detected.\n\nExample: ``microphone.is_event(SoundEvent.LOUD)``\n\nThis call does not clear the sound event history.\n\n:param event: The event to check for,  such as ``SoundEvent.LOUD`` or ``SoundEvent.QUIET``\n:return: ``True`` if sound was the most recent heard, ``False`` otherwise.",
            "version": 0,
            "params": [
                {
                    "name": "event"
                }
            ]
        },
        {
            "acResult": "get_events",
            "type": [
                "function"
            ],
            "documentation": "Get the sound event history as a tuple.\n\nExample: ``microphone.get_events()``\n\nThis call clears the sound history before returning.\n\n:return: A tuple of the event history with the most recent event last.",
            "version": 0
        },
        {
            "acResult": "set_threshold",
            "type": [
                "function"
            ],
            "documentation": "Set the threshold for a sound event.\n\nExample: ``microphone.set_threshold(SoundEvent.LOUD, 250)``\n\nA high threshold means the event will only trigger if the sound is very loud (>= 250 in the example).\n\n:param event: A sound event, such as ``SoundEvent.LOUD`` or ``SoundEvent.QUIET``.\n:param value: The threshold level in the range 0-255.",
            "version": 0,
            "params": [
                {
                    "name": "event"
                },
                {
                    "name": "value"
                }
            ]
        },
        {
            "acResult": "sound_level",
            "type": [
                "function"
            ],
            "documentation": "Get the sound pressure level.\n\nExample: ``microphone.sound_level()``\n\n:return: A representation of the sound pressure level in the range 0 to 255.",
            "version": 0
        }
    ],
    "struct": [
        {
            "acResult": "calcsize",
            "type": [
                "function"
            ],
            "documentation": "Get the number of bytes needed to store the given ``fmt``.\n\nExample: ``struct.calcsize('hf')``\n\n:param fmt: A format string.\n:return The number of bytes needed to store such a value.",
            "version": 0,
            "params": [
                {
                    "name": "fmt"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "format",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "pack",
            "type": [
                "function"
            ],
            "documentation": "Pack values according to a format string.\n\nExample: ``struct.pack('hf', 1, 3.1415)``\n\n:param fmt: The format string.\n:param v1: The first value.\n:param *vn: The remaining values.\n:return A bytes object encoding the values.",
            "version": 0,
            "params": [
                {
                    "name": "format"
                },
                {
                    "name": "v1"
                },
                {
                    "name": "v2"
                }
            ]
        },
        {
            "acResult": "pack_into",
            "type": [
                "function"
            ],
            "documentation": "Pack values according to a format string.\n\nExample: ``struct.pack_info('hf', buffer, 1, 3.1415)``\n\n:param fmt: The format string.\n:param buffer: The target buffer to write into.\n:param offset: The offset into the buffer. May be negative to count from the end of the buffer.\n:param v1: The first value.\n:param *vn: The remaining values.",
            "version": 0,
            "params": [
                {
                    "name": "format"
                },
                {
                    "name": "buffer"
                },
                {
                    "name": "offset"
                },
                {
                    "name": "v1"
                },
                {
                    "name": "v2"
                }
            ]
        },
        {
            "acResult": "unpack",
            "type": [
                "function"
            ],
            "documentation": "Unpack data according to a format string.\n\nExample: ``v1, v2 = struct.unpack('hf', buffer)``\n\n:param fmt: The format string.\n:param data: The data.\n:return: A tuple of the unpacked values.",
            "version": 0,
            "params": [
                {
                    "name": "fmt"
                },
                {
                    "name": "data"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "format",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "buffer",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "unpack_from",
            "type": [
                "function"
            ],
            "documentation": "Unpack data from a buffer according to a format string.\n\nExample: ``v1, v2 = struct.unpack_from('hf', buffer)``\n\n:param fmt: The format string.\n:param buffer: The source buffer to read from.\n:param offset: The offset into the buffer. May be negative to count from the end of the buffer.\n:return: A tuple of the unpacked values.",
            "version": 0,
            "params": [
                {
                    "name": "fmt"
                },
                {
                    "name": "buffer"
                },
                {
                    "name": "offset",
                    "defaultValue": "0"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "format",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "buffer",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "offset",
                        "defaultValue": "0",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        }
    ],
    "uerrno": [],
    "usys": [],
    "os": [
        {
            "acResult": "listdir",
            "type": [
                "function"
            ],
            "documentation": "List files.\n\nExample: ``os.listdir()``\n\n:return: A list of the names of all the files contained within the local\npersistent on-device file system.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "path",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "remove",
            "type": [
                "function"
            ],
            "documentation": "Remove (delete) a file.\n\nExample: ``os.remove('data.txt')``\n\n:param filename: The file to delete.\n\nIf the file does not exist an ``OSError`` exception will occur.",
            "version": 0,
            "params": [
                {
                    "name": "filename"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "path",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [
                    {
                        "name": "dir_fd",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "size",
            "type": [
                "function"
            ],
            "documentation": "Returns the size of a file.\n\nExample: ``os.size('data.txt')``\n\n:param filename: The file\n:return: The size in bytes.\n\nIf the file does not exist an ``OSError`` exception will occur.",
            "version": 0,
            "params": [
                {
                    "name": "filename"
                }
            ],
            "errors": "module 'os' has no attribute 'size'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'os' has no attribute 'size'\n'os.size' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'os' has no attribute 'size'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'os.size' is not a callable object\nNo Python documentation found for 'os.size'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'os' has no attribute 'size'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'os.size' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'os.size'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "uname_result",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Result of ``os.uname()``",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "iterable",
                        "defaultValue": "()",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "uname",
            "type": [
                "function"
            ],
            "documentation": "Returns information identifying the current operating system.\n\nExample: ``os.uname()``\n\nThe return value is an object with five attributes:\n\n- ``sysname`` - operating system name\n- ``nodename`` - name of machine on network (implementation-defined)\n- ``release`` - operating system release\n- ``version`` - operating system version\n- ``machine`` - hardware identifier\n\nThere is no underlying operating system in MicroPython. As a result the\ninformation returned by the ``uname`` function is mostly useful for\nversioning details.",
            "version": 0
        }
    ],
    "log": [
        {
            "acResult": "set_labels",
            "type": [
                "function"
            ],
            "documentation": "Set up the log file header.\n\nExample: ``log.set_labels('X', 'Y', 'Z', timestamp=log.MINUTES)``\n\nIdeally this function should be called a single time, before any data is\nlogged, to configure the data table header once.\n\nIf a log file already exists when the program starts, or if this function\nis called multiple times, it will check the labels already defined in the\nlog file. If this function call contains any new labels not already\npresent, it will generate a new header row with the additional columns.\n\nBy default the first column contains a timestamp for each row. The time\nunit can be selected via the timestamp argument.\n\n:param *labels: Any number of positional arguments, each corresponding to an entry in the log header.\n:param timestamp: Select the timestamp unit that will be automatically added as the first column in every row. Timestamp values can be one of ``log.MILLISECONDS``, ``log.SECONDS``, ``log.MINUTES``, ``log.HOURS``, ``log.DAYS`` or ``None`` to disable the timestamp. The default value is ``log.SECONDS``.",
            "version": 0
        },
        {
            "acResult": "add",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Add a data row to the log by passing a dictionary of headers and values.\n\nExample: ``log.add({ 'temp': temperature() })``\n\nEach call to this function adds a row to the log.\n\nNew labels not previously specified via the set_labels function, or by a\nprevious call to this function, will trigger a new header entry to be added\nto the log with the extra labels.\n\nLabels previously specified and not present in a call to this function will\nbe skipped with an empty value in the log row.\n\n:param data_dictionary: The data to log as a dictionary with a key for each header.",
            "version": 0,
            "params": [
                {
                    "name": "data_dictionary"
                }
            ]
        },
        {
            "acResult": "delete",
            "type": [
                "function"
            ],
            "documentation": "Deletes the contents of the log, including headers.\n\nExample: ``log.delete()``\n\nTo add the log headers again the ``set_labels`` function should to be called after this function.\n\nThere are two erase modes; \u201cfull\u201d completely removes the data from the physical storage,\nand \u201cfast\u201d invalidates the data without removing it.\n\n:param full: ``True`` selects a \u201cfull\u201d erase and ``False`` selects the \u201cfast\u201d erase method.",
            "version": 0,
            "params": [
                {
                    "name": "full",
                    "defaultValue": "False"
                }
            ]
        },
        {
            "acResult": "set_mirroring",
            "type": [
                "function"
            ],
            "documentation": "Configure mirroring of the data logging activity to the serial output.\n\nExample: ``log.set_mirroring(True)``\n\nSerial mirroring is disabled by default. When enabled, it will print to serial each row logged into the log file.\n\n:param serial: ``True`` enables mirroring data to the serial output.",
            "version": 0,
            "params": [
                {
                    "name": "serial"
                }
            ]
        }
    ],
    "types": [
        {
            "acResult": "_Cell",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'types' has no attribute '_Cell'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute '_Cell'\n'types._Cell' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute '_Cell'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types._Cell' is not a callable object\nNo Python documentation found for 'types._Cell'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute '_Cell'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types._Cell' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'types._Cell'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "FunctionType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a function object.\n\ncode\n  a code object\nglobals\n  the globals dictionary\nname\n  a string that overrides the name from the code object\nargdefs\n  a tuple that specifies the default argument values\nclosure\n  a tuple that supplies the bindings for free variables",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "code",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "globals",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "name",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "argdefs",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "closure",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "CodeType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a code object.  Not for the faint of heart.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class code in types\n\nt\bty\byp\bpe\bes\bs.\b.C\bCo\bod\bde\beT\bTy\byp\bpe\be = class code(object)\n |  code(argcount, posonlyargcount, kwonlyargcount, nlocals, stacksize,\n |        flags, codestring, constants, names, varnames, filename, name,\n |        firstlineno, lnotab[, freevars[, cellvars]])\n |  \n |  Create a code object.  Not for the faint of heart.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(...)\n |      Size of object in memory, in bytes.\n |  \n |  r\bre\bep\bpl\bla\bac\bce\be(self, /, *, co_argcount=-1, co_posonlyargcount=-1, co_kwonlyargcount=-1, co_nlocals=-1, co_stacksize=-1, co_flags=-1, co_firstlineno=-1, co_code=None, co_consts=None, co_names=None, co_varnames=None, co_freevars=None, co_cellvars=None, co_filename=None, co_name=None, co_lnotab=None)\n |      Return a copy of the code object with new values for the specified fields.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  c\bco\bo_\b_a\bar\brg\bgc\bco\bou\bun\bnt\bt\n |  \n |  c\bco\bo_\b_c\bce\bel\bll\blv\bva\bar\brs\bs\n |  \n |  c\bco\bo_\b_c\bco\bod\bde\be\n |  \n |  c\bco\bo_\b_c\bco\bon\bns\bst\bts\bs\n |  \n |  c\bco\bo_\b_f\bfi\bil\ble\ben\bna\bam\bme\be\n |  \n |  c\bco\bo_\b_f\bfi\bir\brs\bst\btl\bli\bin\bne\ben\bno\bo\n |  \n |  c\bco\bo_\b_f\bfl\bla\bag\bgs\bs\n |  \n |  c\bco\bo_\b_f\bfr\bre\bee\bev\bva\bar\brs\bs\n |  \n |  c\bco\bo_\b_k\bkw\bwo\bon\bnl\bly\bya\bar\brg\bgc\bco\bou\bun\bnt\bt\n |  \n |  c\bco\bo_\b_l\bln\bno\bot\bta\bab\bb\n |  \n |  c\bco\bo_\b_n\bna\bam\bme\be\n |  \n |  c\bco\bo_\b_n\bna\bam\bme\bes\bs\n |  \n |  c\bco\bo_\b_n\bnl\blo\boc\bca\bal\bls\bs\n |  \n |  c\bco\bo_\b_p\bpo\bos\bso\bon\bnl\bly\bya\bar\brg\bgc\bco\bou\bun\bnt\bt\n |  \n |  c\bco\bo_\b_s\bst\bta\bac\bck\bks\bsi\biz\bze\be\n |  \n |  c\bco\bo_\b_v\bva\bar\brn\bna\bam\bme\bes\bs\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'code'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'types.CodeType' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'code'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.CodeType' is not a callable object\n"
        },
        {
            "acResult": "MappingProxyType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class mappingproxy in types\n\nt\bty\byp\bpe\bes\bs.\b.M\bMa\bap\bpp\bpi\bin\bng\bgP\bPr\bro\box\bxy\byT\bTy\byp\bpe\be = class mappingproxy(object)\n |  Methods defined here:\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return key in self.\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bst\btr\br_\b__\b_(self, /)\n |      Return str(self).\n |  \n |  c\bco\bop\bpy\by(...)\n |      D.copy() -> a shallow copy of D\n |  \n |  g\bge\bet\bt(...)\n |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.\n |  \n |  i\bit\bte\bem\bms\bs(...)\n |      D.items() -> list of D's (key, value) pairs, as 2-tuples\n |  \n |  k\bke\bey\bys\bs(...)\n |      D.keys() -> list of D's keys\n |  \n |  v\bva\bal\blu\bue\bes\bs(...)\n |      D.values() -> list of D's values\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'mappingproxy'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'types.MappingProxyType' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'mappingproxy'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.MappingProxyType' is not a callable object\n"
        },
        {
            "acResult": "SimpleNamespace",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A simple attribute-based namespace.\n\nSimpleNamespace(**kwargs)",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class SimpleNamespace in types\n\nt\bty\byp\bpe\bes\bs.\b.S\bSi\bim\bmp\bpl\ble\beN\bNa\bam\bme\bes\bsp\bpa\bac\bce\be = class SimpleNamespace(builtins.object)\n |  A simple attribute-based namespace.\n |  \n |  SimpleNamespace(**kwargs)\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'types.SimpleNamespace'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'types.SimpleNamespace' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'types.SimpleNamespace'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.SimpleNamespace' is not a callable object\n"
        },
        {
            "acResult": "ModuleType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "doc",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "GeneratorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "AsyncGeneratorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "CoroutineType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "_StaticFunctionType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Fictional type to correct the type of MethodType.__func__.\n\nFunctionType is a descriptor, so mypy follows the descriptor protocol and\nconverts MethodType.__func__ back to MethodType (the return type of\nFunctionType.__get__). But this is actually a special case; MethodType is\nimplemented in C and its attribute access doesn't go through\n__getattribute__.\n\nBy wrapping FunctionType in _StaticFunctionType, we get the right result;\nsimilar to wrapping a function in staticmethod() at runtime to prevent it\nbeing bound as a method.",
            "version": 0,
            "errors": "module 'types' has no attribute '_StaticFunctionType'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute '_StaticFunctionType'\n'types._StaticFunctionType' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute '_StaticFunctionType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types._StaticFunctionType' is not a callable object\nNo Python documentation found for 'types._StaticFunctionType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute '_StaticFunctionType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types._StaticFunctionType' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'types._StaticFunctionType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "MethodType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a bound instance method object.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class method in types\n\nt\bty\byp\bpe\bes\bs.\b.M\bMe\bet\bth\bho\bod\bdT\bTy\byp\bpe\be = class method(object)\n |  method(function, instance)\n |  \n |  Create a bound instance method object.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_c\bca\bal\bll\bl_\b__\b_(self, /, *args, **kwargs)\n |      Call self as a function.\n |  \n |  _\b__\b_d\bde\bel\bla\bat\btt\btr\br_\b__\b_(self, name, /)\n |      Implement delattr(self, name).\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bt_\b__\b_(self, instance, owner, /)\n |      Return an attribute of instance, which is of type owner.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_(self, /)\n |      Return hash(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Helper for pickle.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_s\bse\bet\bta\bat\btt\btr\br_\b__\b_(self, name, value, /)\n |      Implement setattr(self, name, value).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_f\bfu\bun\bnc\bc_\b__\b_\n |      the function (or other callable) implementing a method\n |  \n |  _\b__\b_s\bse\bel\blf\bf_\b__\b_\n |      the instance to which a method is bound\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'method'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'types.MethodType' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'method'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.MethodType' is not a callable object\n"
        },
        {
            "acResult": "BuiltinFunctionType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "WrapperDescriptorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "MethodWrapperType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "MethodDescriptorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "ClassMethodDescriptorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "TracebackType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Create a new traceback object.",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class traceback in types\n\nt\bty\byp\bpe\bes\bs.\b.T\bTr\bra\bac\bce\beb\bba\bac\bck\bkT\bTy\byp\bpe\be = class traceback(object)\n |  TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)\n |  --\n |  \n |  Create a new traceback object.\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_d\bdi\bir\br_\b__\b_(...)\n |      Default dir() implementation.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  t\btb\bb_\b_f\bfr\bra\bam\bme\be\n |  \n |  t\btb\bb_\b_l\bla\bas\bst\bti\bi\n |  \n |  t\btb\bb_\b_l\bli\bin\bne\ben\bno\bo\n |  \n |  t\btb\bb_\b_n\bne\bex\bxt\bt\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'traceback'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'types.TracebackType' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'traceback'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.TracebackType' is not a callable object\n"
        },
        {
            "acResult": "FrameType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "GetSetDescriptorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "MemberDescriptorType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "new_class",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Create a class object dynamically using the appropriate metaclass.",
            "version": 0,
            "params": [
                {
                    "name": "name"
                },
                {
                    "name": "bases",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "kwds",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "exec_body",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "bases",
                        "defaultValue": "()",
                        "argType": "None"
                    },
                    {
                        "name": "kwds",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "exec_body",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "resolve_bases",
            "type": [
                "function"
            ],
            "documentation": "Resolve MRO entries dynamically as specified by PEP 560.",
            "version": 0,
            "params": [
                {
                    "name": "bases"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "bases",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "prepare_class",
            "type": [
                "function"
            ],
            "documentation": "Call the __prepare__ method of the appropriate metaclass.\n\nReturns (metaclass, namespace, kwds) as a 3-tuple\n\n*metaclass* is the appropriate metaclass\n*namespace* is the prepared class namespace\n*kwds* is an updated copy of the passed in kwds argument with any\n'metaclass' entry removed. If no kwds argument is passed in, this will\nbe an empty dict.",
            "version": 0,
            "params": [
                {
                    "name": "name"
                },
                {
                    "name": "bases",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "kwds",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "bases",
                        "defaultValue": "()",
                        "argType": "None"
                    },
                    {
                        "name": "kwds",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "coroutine",
            "type": [
                "function"
            ],
            "documentation": "Convert regular generator function to a coroutine.",
            "version": 0,
            "params": [
                {
                    "name": "func"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "func",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "GenericAlias",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'types' has no attribute 'GenericAlias'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'GenericAlias'\n'types.GenericAlias' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'GenericAlias'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.GenericAlias' is not a callable object\nNo Python documentation found for 'types.GenericAlias'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'GenericAlias'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.GenericAlias' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'types.GenericAlias'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "NoneType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'types' has no attribute 'NoneType'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'NoneType'\n'types.NoneType' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'NoneType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.NoneType' is not a callable object\nNo Python documentation found for 'types.NoneType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'NoneType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.NoneType' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'types.NoneType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "UnionType",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'types' has no attribute 'UnionType'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'UnionType'\n'types.UnionType' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'UnionType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.UnionType' is not a callable object\nNo Python documentation found for 'types.UnionType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'types' has no attribute 'UnionType'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'types.UnionType' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'types.UnionType'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        }
    ],
    "typing": [
        {
            "acResult": "TypeVar",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Type variable.\n\nUsage::\n\n  T = TypeVar('T')  # Can be anything\n  A = TypeVar('A', str, bytes)  # Must be str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function definitions.  See class Generic for more\ninformation on generic types.  Generic functions work as follows:\n\n  def repeat(x: T, n: int) -> List[T]:\n      '''Return a list containing n references to x.'''\n      return [x]*n\n\n  def longest(x: A, y: A) -> A:\n      '''Return the longest of two strings.'''\n      return x if len(x) >= len(y) else y\n\nThe latter example's signature is essentially the overloading\nof (str, str) -> str and (bytes, bytes) -> bytes.  Also note\nthat if the arguments are instances of some subclass of str,\nthe return type is still plain str.\n\nAt runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\nType variables defined with covariant=True or contravariant=True\ncan be used to declare covariant or contravariant generic types.\nSee PEP 484 for more details. By default generic types are invariant\nin all type variables.\n\nType variables can be introspected. e.g.:\n\n  T.__name__ == 'T'\n  T.__constraints__ == ()\n  T.__covariant__ == False\n  T.__contravariant__ = False\n  A.__constraints__ == (str, bytes)\n\nNote that only type variables defined in global scope can be pickled.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "constraints",
                    "argType": "None"
                },
                "keywordOnlyArgs": [
                    {
                        "name": "bound",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "covariant",
                        "defaultValue": "False",
                        "argType": "None"
                    },
                    {
                        "name": "contravariant",
                        "defaultValue": "False",
                        "argType": "None"
                    }
                ],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "_SpecialForm",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Internal indicator of special typing constructs.\nSee _doc instance attribute for specific docs.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "overload",
            "type": [
                "function"
            ],
            "documentation": "Decorator for overloaded functions/methods.\n\nIn a stub file, place two or more stub definitions for the same\nfunction in a row, each decorated with @overload.  For example:\n\n  @overload\n  def utf8(value: None) -> None: ...\n  @overload\n  def utf8(value: bytes) -> bytes: ...\n  @overload\n  def utf8(value: str) -> bytes: ...\n\nIn a non-stub file (i.e. a regular .py file), do the same but\nfollow it with an implementation.  The implementation should *not*\nbe decorated with @overload.  For example:\n\n  @overload\n  def utf8(value: None) -> None: ...\n  @overload\n  def utf8(value: bytes) -> bytes: ...\n  @overload\n  def utf8(value: str) -> bytes: ...\n  def utf8(value):\n      # implementation goes here",
            "version": 0,
            "params": [
                {
                    "name": "func"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "func",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Union",
            "type": [
                "variable"
            ],
            "documentation": "Internal indicator of special typing constructs.\nSee _doc instance attribute for specific docs.",
            "version": 0
        },
        {
            "acResult": "Optional",
            "type": [
                "variable"
            ],
            "documentation": "Internal indicator of special typing constructs.\nSee _doc instance attribute for specific docs.",
            "version": 0
        },
        {
            "acResult": "Tuple",
            "type": [
                "variable"
            ],
            "documentation": "Tuple type; Tuple[X, Y] is the cross-product type of X and Y.\n\nExample: Tuple[T1, T2] is a tuple of two elements corresponding\nto type variables T1 and T2.  Tuple[int, float, str] is a tuple\nof an int, a float and a string.\n\nTo specify a variable-length tuple of homogeneous type, use Tuple[T, ...].",
            "version": 0
        },
        {
            "acResult": "Generic",
            "type": [
                "variable"
            ],
            "documentation": "Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
            "version": 0
        },
        {
            "acResult": "Protocol",
            "type": [
                "variable"
            ],
            "documentation": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing), for example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
            "version": 0
        },
        {
            "acResult": "Callable",
            "type": [
                "variable"
            ],
            "documentation": "Callable type; Callable[[int], str] is a function of (int) -> str.\n\nThe subscription syntax must always be used with exactly two\nvalues: the argument list and the return type.  The argument list\nmust be a list of types or ellipsis; the return type must be a single type.\n\nThere is no syntax to indicate optional or keyword arguments,\nsuch function types are rarely used as callback types.",
            "version": 0
        },
        {
            "acResult": "Type",
            "type": [
                "variable"
            ],
            "documentation": "A special construct usable to annotate class objects.\n\nFor example, suppose we have the following classes::\n\n  class User: ...  # Abstract base for User classes\n  class BasicUser(User): ...\n  class ProUser(User): ...\n  class TeamUser(User): ...\n\nAnd a function that takes a class argument that's a subclass of\nUser and returns an instance of the corresponding class::\n\n  U = TypeVar('U', bound=User)\n  def new_user(user_class: Type[U]) -> U:\n      user = user_class()\n      # (Here we could write the user object to a database)\n      return user\n\n  joe = new_user(BasicUser)\n\nAt this point the type checker knows that joe has type BasicUser.",
            "version": 0
        },
        {
            "acResult": "ClassVar",
            "type": [
                "variable"
            ],
            "documentation": "Internal indicator of special typing constructs.\nSee _doc instance attribute for specific docs.",
            "version": 0
        },
        {
            "acResult": "Final",
            "type": [
                "variable"
            ],
            "documentation": "Internal indicator of special typing constructs.\nSee _doc instance attribute for specific docs.",
            "version": 0
        },
        {
            "acResult": "final",
            "type": [
                "function"
            ],
            "documentation": "A decorator to indicate final methods and final classes.\n\nUse this decorator to indicate to type checkers that the decorated\nmethod cannot be overridden, and decorated class cannot be subclassed.\nFor example:\n\n  class Base:\n      @final\n      def done(self) -> None:\n          ...\n  class Sub(Base):\n      def done(self) -> None:  # Error reported by type checker\n            ...\n\n  @final\n  class Leaf:\n      ...\n  class Other(Leaf):  # Error reported by type checker\n      ...\n\nThere is no runtime checking of these properties.",
            "version": 0,
            "params": [
                {
                    "name": "f"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "f",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Literal",
            "type": [
                "variable"
            ],
            "documentation": "Internal indicator of special typing constructs.\nSee _doc instance attribute for specific docs.",
            "version": 0
        },
        {
            "acResult": "TypedDict",
            "type": [
                "variable"
            ],
            "documentation": "A simple typed namespace. At runtime it is equivalent to a plain dict.\n\nTypedDict creates a dictionary type that expects all of its\ninstances to have a certain set of keys, where each key is\nassociated with a value of a consistent type. This expectation\nis not checked at runtime but is only enforced by type checkers.\nUsage::\n\n    class Point2D(TypedDict):\n        x: int\n        y: int\n        label: str\n\n    a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n    b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\n    assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n\nThe type info can be accessed via Point2D.__annotations__. TypedDict\nsupports two additional equivalent forms::\n\n    Point2D = TypedDict('Point2D', x=int, y=int, label=str)\n    Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n\nBy default, all keys must be present in a TypedDict. It is possible\nto override this by specifying totality.\nUsage::\n\n    class point2D(TypedDict, total=False):\n        x: int\n        y: int\n\nThis means that a point2D TypedDict can have any of the keys omitted.A type\nchecker is only expected to support a literal False or True as the value of\nthe total argument. True is the default, and makes all items defined in the\nclass body be required.\n\nThe class syntax is only supported in Python 3.6+, while two other\nsyntax forms work for Python 2.7 and 3.2+",
            "version": 0
        },
        {
            "acResult": "GenericMeta",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute 'GenericMeta'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'GenericMeta'\n'typing.GenericMeta' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'GenericMeta'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.GenericMeta' is not a callable object\nNo Python documentation found for 'typing.GenericMeta'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'GenericMeta'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.GenericMeta' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.GenericMeta'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ParamSpecArgs",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute 'ParamSpecArgs'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpecArgs'\n'typing.ParamSpecArgs' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpecArgs'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.ParamSpecArgs' is not a callable object\nNo Python documentation found for 'typing.ParamSpecArgs'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpecArgs'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.ParamSpecArgs' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.ParamSpecArgs'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ParamSpecKwargs",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute 'ParamSpecKwargs'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpecKwargs'\n'typing.ParamSpecKwargs' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpecKwargs'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.ParamSpecKwargs' is not a callable object\nNo Python documentation found for 'typing.ParamSpecKwargs'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpecKwargs'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.ParamSpecKwargs' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.ParamSpecKwargs'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ParamSpec",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute 'ParamSpec'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpec'\n'typing.ParamSpec' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpec'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.ParamSpec' is not a callable object\nNo Python documentation found for 'typing.ParamSpec'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'ParamSpec'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.ParamSpec' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.ParamSpec'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "Concatenate",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "TypeAlias",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "TypeGuard",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "no_type_check",
            "type": [
                "function"
            ],
            "documentation": "Decorator to indicate that annotations are not type hints.\n\nThe argument must be a class or function; if it is a class, it\napplies recursively to all methods and classes defined in that class\n(but not to methods defined in its superclasses or subclasses).\n\nThis mutates the function(s) or class(es) in place.",
            "version": 0,
            "params": [
                {
                    "name": "arg"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "arg",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "no_type_check_decorator",
            "type": [
                "function"
            ],
            "documentation": "Decorator to give another decorator the @no_type_check effect.\n\nThis wraps the decorator with something that wraps the decorated\nfunction in @no_type_check.",
            "version": 0,
            "params": [
                {
                    "name": "decorator"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "decorator",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "_Alias",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute '_Alias'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute '_Alias'\n'typing._Alias' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute '_Alias'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing._Alias' is not a callable object\nNo Python documentation found for 'typing._Alias'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute '_Alias'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing._Alias' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing._Alias'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "Annotated",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "runtime_checkable",
            "type": [
                "function"
            ],
            "documentation": "Mark a protocol class as a runtime protocol.\n\nSuch protocol can be used with isinstance() and issubclass().\nRaise TypeError if applied to a non-protocol class.\nThis allows a simple-minded structural check very similar to\none trick ponies in collections.abc such as Iterable.\nFor example::\n\n    @runtime_checkable\n    class Closable(Protocol):\n        def close(self): ...\n\n    assert isinstance(open('/some/file'), Closable)\n\nWarning: this will check only the presence of the required methods,\nnot their type signatures!",
            "version": 0,
            "params": [
                {
                    "name": "cls"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "SupportsInt",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __int__.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "SupportsFloat",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __float__.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "SupportsComplex",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __complex__.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "SupportsBytes",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __bytes__.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "SupportsIndex",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __index__.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "SupportsAbs",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __abs__ that is covariant in its return type.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "SupportsRound",
            "type": [
                "type",
                "function"
            ],
            "documentation": "An ABC with one abstract method __round__ that is covariant in its return type.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "Sized",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Hashable",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Iterable",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Iterator",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Reversible",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Generator",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Awaitable",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Coroutine",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "AwaitableGenerator",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute 'AwaitableGenerator'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'AwaitableGenerator'\n'typing.AwaitableGenerator' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'AwaitableGenerator'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.AwaitableGenerator' is not a callable object\nNo Python documentation found for 'typing.AwaitableGenerator'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'AwaitableGenerator'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.AwaitableGenerator' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.AwaitableGenerator'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "AsyncIterable",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "AsyncIterator",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "AsyncGenerator",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Container",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Collection",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Sequence",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "MutableSequence",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "AbstractSet",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "MutableSet",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "MappingView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "ItemsView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "KeysView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "ValuesView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "ContextManager",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "AsyncContextManager",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Mapping",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "MutableMapping",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "IO",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "BinaryIO",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Typed version of the return of open() in binary mode.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "TextIO",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Typed version of the return of open() in text mode.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwds",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "ByteString",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Match",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "Pattern",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The central part of internal API.\n\nThis represents a generic version of type 'origin' with type arguments 'params'.\nThere are two kind of these aliases: user defined and special. The special ones\nare wrappers around builtin collections and ABCs in collections.abc. These must\nhave 'name' always set. If 'inst' is False, then the alias can't be instantiated,\nthis is used by e.g. typing.List and typing.Dict.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": {
                    "name": "args",
                    "argType": "None"
                },
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "get_type_hints",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Return type hints for an object.\n\nThis is often the same as obj.__annotations__, but it handles\nforward references encoded as string literals, and if necessary\nadds Optional[t] if a default value equal to None is set.\n\nThe argument may be a module, class, method, or function. The annotations\nare returned as a dictionary. For classes, annotations include also\ninherited members.\n\nTypeError is raised if the argument is not of a type that can contain\nannotations, and an empty dictionary is returned if no annotations are\npresent.\n\nBEWARE -- the behavior of globalns and localns is counterintuitive\n(unless you are familiar with how eval() and exec() work).  The\nsearch order is locals first, then globals.\n\n- If no dict arguments are passed, an attempt is made to use the\n  globals from obj (or the respective module's globals for classes),\n  and these are also used as the locals.  If the object does not appear\n  to have globals, an empty dictionary is used.\n\n- If one dict argument is passed, it is used for both globals and\n  locals.\n\n- If two dict arguments are passed, they specify globals and\n  locals, respectively.",
            "version": 0,
            "params": [
                {
                    "name": "obj"
                },
                {
                    "name": "globalns",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "localns",
                    "defaultValue": "Ellipsis"
                },
                {
                    "name": "include_extras",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "obj",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "globalns",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "localns",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "get_origin",
            "type": [
                "function"
            ],
            "documentation": "Get the unsubscripted version of a type.\n\nThis supports generic types, Callable, Tuple, Union, Literal, Final and ClassVar.\nReturn None for unsupported types. Examples::\n\n    get_origin(Literal[42]) is Literal\n    get_origin(int) is None\n    get_origin(ClassVar[int]) is ClassVar\n    get_origin(Generic) is Generic\n    get_origin(Generic[T]) is Generic\n    get_origin(Union[T, int]) is Union\n    get_origin(List[Tuple[T, T]][int]) == list",
            "version": 0,
            "params": [
                {
                    "name": "tp"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "tp",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "get_args",
            "type": [
                "function"
            ],
            "documentation": "Get type arguments with all substitutions performed.\n\nFor unions, basic simplifications used by Union constructor are performed.\nExamples::\n    get_args(Dict[str, int]) == (str, int)\n    get_args(int) == ()\n    get_args(Union[int, Union[T, int], str][int]) == (int, str)\n    get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n    get_args(Callable[[], T][int]) == ([], int)",
            "version": 0,
            "params": [
                {
                    "name": "tp"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "tp",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "cast",
            "type": [
                "function",
                "function",
                "function"
            ],
            "documentation": "Cast a value to a type.\n\nThis returns the value unchanged.  To the type checker this\nsignals that the return value has the designated type, but at\nruntime we intentionally don't check anything (we want this\nto be as fast as possible).",
            "version": 0,
            "params": [
                {
                    "name": "typ"
                },
                {
                    "name": "val"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "typ",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "val",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "NamedTuple",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Typed version of namedtuple.\n\nUsage in Python versions >= 3.6::\n\n    class Employee(NamedTuple):\n        name: str\n        id: int\n\nThis is equivalent to::\n\n    Employee = collections.namedtuple('Employee', ['name', 'id'])\n\nThe resulting class has an extra __annotations__ attribute, giving a\ndict that maps field names to types.  (The field names are also in\nthe _fields attribute, which is part of the namedtuple API.)\nAlternative equivalent keyword syntax is also accepted::\n\n    Employee = NamedTuple('Employee', name=str, id=int)\n\nIn Python versions <= 3.5 use::\n\n    Employee = NamedTuple('Employee', [('name', str), ('id', int)])",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "cls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "typename",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "fields",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "_TypedDict",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'typing' has no attribute '_TypedDict'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute '_TypedDict'\n'typing._TypedDict' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute '_TypedDict'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing._TypedDict' is not a callable object\nNo Python documentation found for 'typing._TypedDict'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute '_TypedDict'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing._TypedDict' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing._TypedDict'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "NewType",
            "type": [
                "function"
            ],
            "documentation": "NewType creates simple unique types with almost zero\nruntime overhead. NewType(name, tp) is considered a subtype of tp\nby static type checkers. At runtime, NewType(name, tp) returns\na dummy function that simply returns its argument. Usage::\n\n    UserId = NewType('UserId', int)\n\n    def name_by_id(user_id: UserId) -> str:\n        ...\n\n    UserId('user')          # Fails type check\n\n    name_by_id(42)          # Fails type check\n    name_by_id(UserId(42))  # OK\n\n    num = UserId(5) + 1     # type: int",
            "version": 0,
            "params": [
                {
                    "name": "name"
                },
                {
                    "name": "tp"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "tp",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "type_check_only",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "func_or_cls"
                }
            ],
            "errors": "module 'typing' has no attribute 'type_check_only'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'type_check_only'\n'typing.type_check_only' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'type_check_only'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.type_check_only' is not a callable object\nNo Python documentation found for 'typing.type_check_only'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'type_check_only'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.type_check_only' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.type_check_only'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ForwardRef",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Internal wrapper to hold a forward reference.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "arg",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "is_argument",
                        "defaultValue": "True",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "is_typeddict",
            "type": [
                "function"
            ],
            "documentation": "",
            "version": 0,
            "params": [
                {
                    "name": "tp"
                }
            ],
            "errors": "module 'typing' has no attribute 'is_typeddict'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'is_typeddict'\n'typing.is_typeddict' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'is_typeddict'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.is_typeddict' is not a callable object\nNo Python documentation found for 'typing.is_typeddict'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'typing' has no attribute 'is_typeddict'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'typing.is_typeddict' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'typing.is_typeddict'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        }
    ],
    "urandom": [],
    "time": [
        {
            "acResult": "sleep",
            "type": [
                "function"
            ],
            "documentation": "Delay a number of seconds.\n\nExample: ``time.sleep(1)``\n\n:param seconds: The number of seconds to sleep for.\nUse a floating-point number to sleep for a fractional number of seconds.",
            "version": 0,
            "params": [
                {
                    "name": "seconds"
                }
            ],
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: built-in function sleep in time\n\nt\bti\bim\bme\be.\b.s\bsl\ble\bee\bep\bp = sleep(...)\n    sleep(seconds)\n    \n    Delay execution for a given number of seconds.  The argument may be\n    a floating point number for subsecond precision.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function sleep>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'time.sleep' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2308, in _signature_from_callable\n    return _signature_from_builtin(sigcls, obj,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2119, in _signature_from_builtin\n    raise ValueError(\"no signature found for builtin {!r}\".format(func))\nValueError: no signature found for builtin <built-in function sleep>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.sleep' is not a callable object\n"
        },
        {
            "acResult": "sleep_ms",
            "type": [
                "function"
            ],
            "documentation": "Delay for given number of milliseconds.\n\nExample: ``time.sleep_ms(1_000_000)``\n\n:param ms: The number of milliseconds delay (>= 0).",
            "version": 0,
            "params": [
                {
                    "name": "ms"
                }
            ],
            "errors": "module 'time' has no attribute 'sleep_ms'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'sleep_ms'\n'time.sleep_ms' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'sleep_ms'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.sleep_ms' is not a callable object\nNo Python documentation found for 'time.sleep_ms'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'sleep_ms'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.sleep_ms' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'time.sleep_ms'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "sleep_us",
            "type": [
                "function"
            ],
            "documentation": "Delay for given number of microseconds.\n\nExample: ``time.sleep_us(1000)``\n\n:param us: The number of microseconds delay (>= 0).",
            "version": 0,
            "params": [
                {
                    "name": "us"
                }
            ],
            "errors": "module 'time' has no attribute 'sleep_us'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'sleep_us'\n'time.sleep_us' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'sleep_us'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.sleep_us' is not a callable object\nNo Python documentation found for 'time.sleep_us'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'sleep_us'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.sleep_us' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'time.sleep_us'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ticks_ms",
            "type": [
                "function"
            ],
            "documentation": "Get an increasing, millisecond counter with an arbitrary reference point,\nthat wraps around after some value.\n\nExample: ``time.ticks_ms()``\n\n:return: The counter value in milliseconds.",
            "version": 0,
            "errors": "module 'time' has no attribute 'ticks_ms'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_ms'\n'time.ticks_ms' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_ms'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_ms' is not a callable object\nNo Python documentation found for 'time.ticks_ms'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_ms'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_ms' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'time.ticks_ms'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ticks_us",
            "type": [
                "function"
            ],
            "documentation": "Get an increasing, microsecond counter with an arbitrary reference point,\nthat wraps around after some value.\n\nExample: ``time.ticks_us()``\n\n:return: The counter value in microseconds.",
            "version": 0,
            "errors": "module 'time' has no attribute 'ticks_us'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_us'\n'time.ticks_us' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_us'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_us' is not a callable object\nNo Python documentation found for 'time.ticks_us'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_us'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_us' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'time.ticks_us'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ticks_add",
            "type": [
                "function"
            ],
            "documentation": "Offset ticks value by a given number, which can be either positive or\nnegative.\n\nExample: ``time.ticks_add(time.ticks_ms(), 200)``\n\nGiven a ticks value, this function allows to calculate ticks\nvalue delta ticks before or after it, following modular-arithmetic\ndefinition of tick values.\n\n:param ticks: A ticks value\n:param delta: An integer offset\n\nExample::\n\n    # Find out what ticks value there was 100ms ago\n    print(ticks_add(time.ticks_ms(), -100))\n\n    # Calculate deadline for operation and test for it\n    deadline = ticks_add(time.ticks_ms(), 200)\n    while ticks_diff(deadline, time.ticks_ms()) > 0:\n        do_a_little_of_something()\n\n    # Find out TICKS_MAX used by this port\n    print(ticks_add(0, -1))",
            "version": 0,
            "params": [
                {
                    "name": "ticks"
                },
                {
                    "name": "delta"
                }
            ],
            "errors": "module 'time' has no attribute 'ticks_add'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_add'\n'time.ticks_add' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_add'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_add' is not a callable object\nNo Python documentation found for 'time.ticks_add'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_add'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_add' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'time.ticks_add'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "ticks_diff",
            "type": [
                "function"
            ],
            "documentation": "Measure ticks difference between values returned from\n``time.ticks_ms()`` or ``ticks_us()``, as a signed value\nwhich may wrap around.\n\nExample: ``time.ticks_diff(scheduled_time, now)``\n\n:param ticks1: The value to subtract from\n:param ticks2: The value to subtract\n\nThe argument order is the same as for subtraction operator,\n``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - ticks2``.\n\n``ticks_diff()`` is designed to accommodate various usage\npatterns, among them:\n\nPolling with timeout. In this case, the order of events is known, and you\nwill deal only with positive results of :func:`time.ticks_diff()`::\n\n    # Wait for GPIO pin to be asserted, but at most 500us\n    start = time.ticks_us()\n    while pin.value() == 0:\n        if time.ticks_diff(time.ticks_us(), start) > 500:\n            raise TimeoutError\n\n\nScheduling events. In this case, :func:`time.ticks_diff()` result may be\nnegative if an event is overdue::\n\n    # This code snippet is not optimized\n    now = time.ticks_ms()\n    scheduled_time = task.scheduled_time()\n    if ticks_diff(scheduled_time, now) > 0:\n        print(\"Too early, let's nap\")\n        sleep_ms(ticks_diff(scheduled_time, now))\n        task.run()\n    elif ticks_diff(scheduled_time, now) == 0:\n        print(\"Right at time!\")\n        task.run()\n    elif ticks_diff(scheduled_time, now) < 0:\n        print(\"Oops, running late, tell task to run faster!\")\n        task.run(run_faster=True)",
            "version": 0,
            "params": [
                {
                    "name": "ticks1"
                },
                {
                    "name": "ticks2"
                }
            ],
            "errors": "module 'time' has no attribute 'ticks_diff'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_diff'\n'time.ticks_diff' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_diff'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_diff' is not a callable object\nNo Python documentation found for 'time.ticks_diff'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'time' has no attribute 'ticks_diff'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'time.ticks_diff' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'time.ticks_diff'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        }
    ],
    "radio": [
        {
            "acResult": "RATE_1MBIT",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "RATE_2MBIT",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "on",
            "type": [
                "function"
            ],
            "documentation": "Turns the radio on.\n\nExample: ``radio.on()``\n\nThis needs to be explicitly called since the radio draws power and takes\nup memory that you may otherwise need.",
            "version": 0
        },
        {
            "acResult": "off",
            "type": [
                "function"
            ],
            "documentation": "Turns off the radio, saving power and memory.\n\nExample: ``radio.off()``",
            "version": 0
        },
        {
            "acResult": "config",
            "type": [
                "function"
            ],
            "documentation": "Configures the radio.\n\nExample: ``radio.config(group=42)``\n\nThe default configuration is suitable for most use.\n\n:param length: (default=32) defines the maximum length, in bytes, of a message sent via the radio.\nIt can be up to 251 bytes long (254 - 3 bytes for S0, LENGTH and S1 preamble).\n:param queue: (default=3) specifies the number of messages that can be stored on the incoming message queue.\nIf there are no spaces left on the queue for incoming messages, then the incoming message is dropped.\n:param channel: (default=7) an integer value from 0 to 83 (inclusive) that defines an arbitrary \"channel\" to which the radio is tuned.\nMessages will be sent via this channel and only messages received via this channel will be put onto the incoming message queue. Each step is 1MHz wide, based at 2400MHz.\n:param power: (default=6) is an integer value from 0 to 7 (inclusive) to indicate the strength of signal used when broadcasting a message.\nThe higher the value the stronger the signal, but the more power is consumed by the device. The numbering translates to positions in the following list of dBm (decibel milliwatt) values: -30, -20, -16, -12, -8, -4, 0, 4.\n:param address: (default=0x75626974) an arbitrary name, expressed as a 32-bit address, that's used to filter incoming packets at the hardware level, keeping only those that match the address you set.\nThe default used by other micro:bit related platforms is the default setting used here.\n:param group: (default=0) an 8-bit value (0-255) used with the ``address`` when filtering messages.\nConceptually, \"address\" is like a house/office address and \"group\" is like the person at that address to which you want to send your message.\n:param data_rate: (default=``radio.RATE_1MBIT``) indicates the speed at which data throughput takes place.\nCan be one of the following constants defined in the ``radio`` module: ``RATE_250KBIT``, ``RATE_1MBIT`` or ``RATE_2MBIT``.\n\nIf ``config`` is not called then the defaults described above are assumed.",
            "version": 0,
            "params": [
                {
                    "name": "length"
                },
                {
                    "name": "queue",
                    "defaultValue": "0"
                },
                {
                    "name": "channel",
                    "defaultValue": "1969383796"
                },
                {
                    "name": "power",
                    "defaultValue": "6"
                },
                {
                    "name": "address",
                    "defaultValue": "7"
                },
                {
                    "name": "group",
                    "defaultValue": "3"
                },
                {
                    "name": "data_rate",
                    "defaultValue": "32"
                }
            ]
        },
        {
            "acResult": "reset",
            "type": [
                "function"
            ],
            "documentation": "Reset the settings to their default values.\n\nExample: ``radio.reset()``\n\nThe defaults as as per the ``config`` function above.",
            "version": 0
        },
        {
            "acResult": "send_bytes",
            "type": [
                "function"
            ],
            "documentation": "Sends a message containing bytes.\n\nExample: ``radio.send_bytes(b'hello')``\n\n:param message: The bytes to send.",
            "version": 0,
            "params": [
                {
                    "name": "message"
                }
            ]
        },
        {
            "acResult": "receive_bytes",
            "type": [
                "function"
            ],
            "documentation": "Receive the next incoming message on the message queue.\n\nExample: ``radio.receive_bytes()``\n\n:return: The message bytes if any, otherwise ``None``.",
            "version": 0
        },
        {
            "acResult": "receive_bytes_into",
            "type": [
                "function"
            ],
            "documentation": "Copy the next incoming message on the message queue into a buffer.\n\nExample: ``radio.receive_bytes_info(buffer)``\n\n:param buffer: The target buffer. The message is truncated if larger than the buffer.\n:return: ``None`` if there are no pending messages, otherwise it returns the length of the message (which might be more than the length of the buffer).",
            "version": 0,
            "params": [
                {
                    "name": "buffer"
                }
            ]
        },
        {
            "acResult": "send",
            "type": [
                "function"
            ],
            "documentation": "Sends a message string.\n\nExample: ``radio.send('hello')``\n\nThis is the equivalent of ``radio.send_bytes(bytes(message, 'utf8'))`` but with ``b'\u0001\u0000\u0001'``\nprepended to the front (to make it compatible with other platforms that target the micro:bit).\n\n:param message: The string to send.",
            "version": 0,
            "params": [
                {
                    "name": "message"
                }
            ]
        },
        {
            "acResult": "receive",
            "type": [
                "function"
            ],
            "documentation": "Works in exactly the same way as ``receive_bytes`` but returns whatever was sent.\n\nExample: ``radio.receive()``\n\nEquivalent to ``str(receive_bytes(), 'utf8')`` but with a check that the the first\nthree bytes are ``b'\u0001\u0000\u0001'`` (to make it compatible with other platforms that\nmay target the micro:bit).\n\n:return: The message with the prepended bytes stripped and converted to a string.\n\nA ``ValueError`` exception is raised if conversion to string fails.",
            "version": 0
        },
        {
            "acResult": "receive_full",
            "type": [
                "function"
            ],
            "documentation": "Returns a tuple containing three values representing the next incoming message on the message queue.\n\nExample: ``radio.receive_full()``\n\nIf there are no pending messages then ``None`` is returned.\n\nThe three values in the tuple represent:\n\n- the next incoming message on the message queue as bytes.\n- the RSSI (signal strength): a value between 0 (strongest) and -255 (weakest) as measured in dBm.\n- a microsecond timestamp: the value returned by ``time.ticks_us()`` when the message was received.\n\nFor example::\n\n    details = radio.receive_full()\n    if details:\n        msg, rssi, timestamp = details\n\nThis function is useful for providing information needed for triangulation\nand/or trilateration with other micro:bit devices.\n\n:return: ``None`` if there is no message, otherwise a tuple of length three with the bytes, strength and timestamp values.",
            "version": 0
        }
    ],
    "machine": [
        {
            "acResult": "unique_id",
            "type": [
                "function"
            ],
            "documentation": "Get a byte string with a unique identifier of a board.\n\nExample: ``machine.unique_id()``\n\n:return: An identifier that varies from one board instance to another.",
            "version": 0
        },
        {
            "acResult": "reset",
            "type": [
                "function"
            ],
            "documentation": "Reset the device in a manner similar to pushing the external RESET button.\n\nExample: ``machine.reset()``",
            "version": 0
        },
        {
            "acResult": "freq",
            "type": [
                "function"
            ],
            "documentation": "Get the CPU frequency in hertz.\n\nExample: ``machine.freq()``\n\n:return: The CPU frequency.",
            "version": 0
        },
        {
            "acResult": "disable_irq",
            "type": [
                "function"
            ],
            "documentation": "Disable interrupt requests.\n\nExample: ``interrupt_state = machine.disable_irq()``\n\n:return: the previous IRQ state which should be considered an opaque value\n\nThe return value should be passed to the ``enable_irq`` function to restore\ninterrupts to their original state.",
            "version": 0
        },
        {
            "acResult": "enable_irq",
            "type": [
                "function"
            ],
            "documentation": "Re-enable interrupt requests.\n\nExample: ``machine.enable_irq(interrupt_state)``\n\n:param state: The value that was returned from the most recent call to the ``disable_irq`` function.",
            "version": 0,
            "params": [
                {
                    "name": "state"
                }
            ]
        },
        {
            "acResult": "time_pulse_us",
            "type": [
                "function"
            ],
            "documentation": "Time a pulse on a pin.\n\nExample: ``time_pulse_us(pin0, 1)``\n\nIf the current input value of the pin is different to ``pulse_level``, the\nfunction first waits until the pin input becomes equal to\n``pulse_level``, then times the duration that the pin is equal to\n``pulse_level``. If the pin is already equal to ``pulse_level`` then timing\nstarts straight away.\n\n:param pin: The pin to use\n:param pulse_level: 0 to time a low pulse or 1 to time a high pulse\n:param timeout_us: A microsecond timeout\n:return: The duration of the pulse in microseconds, or -1 for a timeout waiting for the level to match ``pulse_level``, or -2 on timeout waiting for the pulse to end",
            "version": 0,
            "params": [
                {
                    "name": "pin"
                },
                {
                    "name": "pulse_level"
                },
                {
                    "name": "timeout_us",
                    "defaultValue": "1000000"
                }
            ]
        },
        {
            "acResult": "mem",
            "type": [
                "type",
                "function"
            ],
            "documentation": "The class for the ``mem8``, ``mem16`` and ``mem32`` memory views.",
            "version": 0
        },
        {
            "acResult": "mem8",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "mem16",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "mem32",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        }
    ],
    "sys": [
        {
            "acResult": "exit",
            "type": [
                "function"
            ],
            "documentation": "Terminate current program with a given exit code.\n\nExample: ``sys.exit(1)``\n\nThis function raises a ``SystemExit`` exception. If an argument is given, its\nvalue given as an argument to ``SystemExit``.\n\n:param retval: The exit code or message.",
            "version": 0,
            "params": [
                {
                    "name": "retval",
                    "defaultValue": "Ellipsis"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "status",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "print_exception",
            "type": [
                "function"
            ],
            "documentation": "Print an exception with a traceback.\n\nExample: ``sys.print_exception(e)``\n\n:param exc: The exception to print\n\nThis is simplified version of a function which appears in the\n``traceback`` module in CPython.",
            "version": 0,
            "params": [
                {
                    "name": "exc"
                }
            ],
            "errors": "module 'sys' has no attribute 'print_exception'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'sys' has no attribute 'print_exception'\n'sys.print_exception' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'sys' has no attribute 'print_exception'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'sys.print_exception' is not a callable object\nNo Python documentation found for 'sys.print_exception'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'sys' has no attribute 'print_exception'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'sys.print_exception' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'sys.print_exception'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "argv",
            "type": [
                "variable"
            ],
            "documentation": "Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",
            "version": 0
        },
        {
            "acResult": "byteorder",
            "type": [
                "variable"
            ],
            "documentation": "Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
            "version": 0
        },
        {
            "acResult": "_implementation",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "errors": "module 'sys' has no attribute '_implementation'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'sys' has no attribute '_implementation'\n'sys._implementation' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'sys' has no attribute '_implementation'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'sys._implementation' is not a callable object\nNo Python documentation found for 'sys._implementation'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'sys' has no attribute '_implementation'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'sys._implementation' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'sys._implementation'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "implementation",
            "type": [
                "variable"
            ],
            "documentation": "A simple attribute-based namespace.\n\nSimpleNamespace(**kwargs)",
            "version": 0
        },
        {
            "acResult": "maxsize",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "modules",
            "type": [
                "variable"
            ],
            "documentation": "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
            "version": 0
        },
        {
            "acResult": "path",
            "type": [
                "variable"
            ],
            "documentation": "Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",
            "version": 0
        },
        {
            "acResult": "platform",
            "type": [
                "variable"
            ],
            "documentation": "Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
            "version": 0
        },
        {
            "acResult": "version",
            "type": [
                "variable"
            ],
            "documentation": "Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
            "version": 0
        },
        {
            "acResult": "version_info",
            "type": [
                "variable"
            ],
            "documentation": "sys.version_info\n\nVersion information as a named tuple.",
            "version": 0
        }
    ],
    "abc": [
        {
            "acResult": "ABCMeta",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "mcls",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "name",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "bases",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "namespace",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": {
                    "name": "kwargs",
                    "argType": "None"
                },
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "abstractmethod",
            "type": [
                "function"
            ],
            "documentation": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.  abstractmethod() may be used to declare\nabstract methods for properties and descriptors.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...",
            "version": 0,
            "params": [
                {
                    "name": "funcobj"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "funcobj",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "abstractproperty",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A decorator indicating abstract properties.\n\nDeprecated, use 'property' with 'abstractmethod' instead.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "fget",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "fset",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "fdel",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "doc",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "abstractstaticmethod",
            "type": [
                "function"
            ],
            "documentation": "A decorator indicating abstract staticmethods.\n\nDeprecated, use 'staticmethod' with 'abstractmethod' instead.",
            "version": 0,
            "params": [
                {
                    "name": "callable"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "callable",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "abstractclassmethod",
            "type": [
                "function"
            ],
            "documentation": "A decorator indicating abstract classmethods.\n\nDeprecated, use 'classmethod' with 'abstractmethod' instead.",
            "version": 0,
            "params": [
                {
                    "name": "callable"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "callable",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "ABC",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Helper class that provides a standard way to create an ABC using\ninheritance.",
            "version": 0
        },
        {
            "acResult": "get_cache_token",
            "type": [
                "function"
            ],
            "documentation": "Returns the current ABC cache token.\n\nThe token is an opaque object (supporting equality testing) identifying the\ncurrent version of the ABC cache for virtual subclasses. The token changes\nwith every call to register() on any ABC.",
            "version": 0
        }
    ],
    "errno": [
        {
            "acResult": "errorcode",
            "type": [
                "variable"
            ],
            "documentation": "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
            "version": 0
        },
        {
            "acResult": "EACCES",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EADDRINUSE",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EAGAIN",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EALREADY",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EBADF",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ECONNABORTED",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ECONNREFUSED",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ECONNRESET",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EEXIST",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EHOSTUNREACH",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EINPROGRESS",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EINVAL",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EIO",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EISDIR",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ENOBUFS",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ENODEV",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ENOENT",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ENOMEM",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ENOTCONN",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EOPNOTSUPP",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "EPERM",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        },
        {
            "acResult": "ETIMEDOUT",
            "type": [
                "variable"
            ],
            "documentation": "Convert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "version": 0
        }
    ],
    "ustruct": [],
    "gc": [
        {
            "acResult": "enable",
            "type": [
                "function"
            ],
            "documentation": "Enable automatic garbage collection.",
            "version": 0
        },
        {
            "acResult": "disable",
            "type": [
                "function"
            ],
            "documentation": "Disable automatic garbage collection.\n\nHeap memory can still be allocated,\nand garbage collection can still be initiated manually using ``gc.collect``.",
            "version": 0
        },
        {
            "acResult": "collect",
            "type": [
                "function"
            ],
            "documentation": "Run a garbage collection.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "generation",
                        "defaultValue": "2",
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "mem_alloc",
            "type": [
                "function"
            ],
            "documentation": "Get the number of bytes of heap RAM that are allocated.\n\n:return: The number of bytes allocated.\n\nThis function is MicroPython extension.",
            "version": 0,
            "errors": "module 'gc' has no attribute 'mem_alloc'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'mem_alloc'\n'gc.mem_alloc' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'mem_alloc'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'gc.mem_alloc' is not a callable object\nNo Python documentation found for 'gc.mem_alloc'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'mem_alloc'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'gc.mem_alloc' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'gc.mem_alloc'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "mem_free",
            "type": [
                "function"
            ],
            "documentation": "Get the number of bytes of available heap RAM, or -1 if this amount is not known.\n\n:return: The number of bytes free.\n\nThis function is MicroPython extension.",
            "version": 0,
            "errors": "module 'gc' has no attribute 'mem_free'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'mem_free'\n'gc.mem_free' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'mem_free'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'gc.mem_free' is not a callable object\nNo Python documentation found for 'gc.mem_free'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'mem_free'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'gc.mem_free' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'gc.mem_free'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        },
        {
            "acResult": "threshold",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Query the additional GC allocation threshold.\n\n:return: The GC allocation threshold.\n\nThis function is a MicroPython extension. CPython has a similar\nfunction - ``set_threshold()``, but due to different GC\nimplementations, its signature and semantics are different.",
            "version": 0,
            "errors": "module 'gc' has no attribute 'threshold'Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'threshold'\n'gc.threshold' is not a callable objectTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'threshold'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'gc.threshold' is not a callable object\nNo Python documentation found for 'gc.threshold'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.Traceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\nAttributeError: module 'gc' has no attribute 'threshold'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'gc.threshold' is not a callable object\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 245, in <module>\n    rendered_doc = pydoc.render_doc(mod + \".\" + item['acResult'])\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1665, in render_doc\n    object, name = resolve(thing, forceload)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pydoc.py\", line 1651, in resolve\n    raise ImportError('''\\\nImportError: No Python documentation found for 'gc.threshold'.\nUse help() to get the interactive help utility.\nUse help(str) for help on the str class.\n"
        }
    ],
    "collections": [
        {
            "acResult": "namedtuple",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
            "version": 0,
            "params": [
                {
                    "name": "typename"
                },
                {
                    "name": "field_names"
                }
            ],
            "signature": {
                "positionalOnlyArgs": [],
                "positionalOrKeywordArgs": [
                    {
                        "name": "typename",
                        "defaultValue": null,
                        "argType": "None"
                    },
                    {
                        "name": "field_names",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [
                    {
                        "name": "rename",
                        "defaultValue": "False",
                        "argType": "None"
                    },
                    {
                        "name": "defaults",
                        "defaultValue": "None",
                        "argType": "None"
                    },
                    {
                        "name": "module",
                        "defaultValue": "None",
                        "argType": "None"
                    }
                ],
                "varKwargs": null,
                "firstParamIsSelfOrCls": false
            }
        },
        {
            "acResult": "_OrderedDictKeysView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A set is a finite, iterable container.\n\nThis class provides concrete generic implementations of all\nmethods except for __contains__, __iter__ and __len__.\n\nTo override the comparisons (presumably for speed, as the\nsemantics are fixed), redefine __le__ and __ge__,\nthen the other operations will automatically follow suit.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "mapping",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "_OrderedDictItemsView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "A set is a finite, iterable container.\n\nThis class provides concrete generic implementations of all\nmethods except for __contains__, __iter__ and __len__.\n\nTo override the comparisons (presumably for speed, as the\nsemantics are fixed), redefine __le__ and __ge__,\nthen the other operations will automatically follow suit.",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "mapping",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "_OrderedDictValuesView",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0,
            "signature": {
                "positionalOnlyArgs": [
                    {
                        "name": "self",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "positionalOrKeywordArgs": [
                    {
                        "name": "mapping",
                        "defaultValue": null,
                        "argType": "None"
                    }
                ],
                "varArgs": null,
                "keywordOnlyArgs": [],
                "varKwargs": null,
                "firstParamIsSelfOrCls": true
            }
        },
        {
            "acResult": "OrderedDict",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Dictionary that remembers insertion order",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class OrderedDict in collections\n\nc\bco\bol\bll\ble\bec\bct\bti\bio\bon\bns\bs.\b.O\bOr\brd\bde\ber\bre\bed\bdD\bDi\bic\bct\bt = class OrderedDict(builtins.dict)\n |  Dictionary that remembers insertion order\n |  \n |  Method resolution order:\n |      OrderedDict\n |      builtins.dict\n |      builtins.object\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_d\bde\bel\bli\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Delete self[key].\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bin\bni\bit\bt_\b__\b_(self, /, *args, **kwargs)\n |      Initialize self.  See help(type(self)) for accurate signature.\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b__\b_(...)\n |      Return state information for pickling\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\bre\bev\bve\ber\brs\bse\bed\bd_\b__\b_(...)\n |      od.__reversed__() <==> reversed(od)\n |  \n |  _\b__\b_s\bse\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, value, /)\n |      Set self[key] to value.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(...)\n |      D.__sizeof__() -> size of D in memory, in bytes\n |  \n |  c\bcl\ble\bea\bar\br(...)\n |      od.clear() -> None.  Remove all items from od.\n |  \n |  c\bco\bop\bpy\by(...)\n |      od.copy() -> a shallow copy of od\n |  \n |  i\bit\bte\bem\bms\bs(...)\n |      D.items() -> a set-like object providing a view on D's items\n |  \n |  k\bke\bey\bys\bs(...)\n |      D.keys() -> a set-like object providing a view on D's keys\n |  \n |  m\bmo\bov\bve\be_\b_t\bto\bo_\b_e\ben\bnd\bd(self, /, key, last=True)\n |      Move an existing element to the end (or beginning if last is false).\n |      \n |      Raise KeyError if the element does not exist.\n |  \n |  p\bpo\bop\bp(...)\n |      od.pop(k[,d]) -> v, remove specified key and return the corresponding\n |      value.  If key is not found, d is returned if given, otherwise KeyError\n |      is raised.\n |  \n |  p\bpo\bop\bpi\bit\bte\bem\bm(self, /, last=True)\n |      Remove and return a (key, value) pair from the dictionary.\n |      \n |      Pairs are returned in LIFO order if last is true or FIFO order if false.\n |  \n |  s\bse\bet\btd\bde\bef\bfa\bau\bul\blt\bt(self, /, key, default=None)\n |      Insert key with a value of default if key is not in the dictionary.\n |      \n |      Return the value for key if key is in the dictionary, else default.\n |  \n |  u\bup\bpd\bda\bat\bte\be(...)\n |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\n |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\n |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\n |      In either case, this is followed by: for k in F:  D[k] = F[k]\n |  \n |  v\bva\bal\blu\bue\bes\bs(...)\n |      D.values() -> an object providing a view on D's values\n |  \n |  ----------------------------------------------------------------------\n |  Class methods defined here:\n |  \n |  f\bfr\bro\bom\bmk\bke\bey\bys\bs(iterable, value=None) from builtins.type\n |      Create a new ordered dictionary with keys from iterable and values set to value.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  _\b__\b_d\bdi\bic\bct\bt_\b__\b_\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n |  \n |  ----------------------------------------------------------------------\n |  Methods inherited from builtins.dict:\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      True if the dictionary has the specified key, else False.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(...)\n |      x.__getitem__(y) <==> x[y]\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  g\bge\bet\bt(self, key, default=None, /)\n |      Return the value for key if key is in the dictionary, else default.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods inherited from builtins.dict:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'collections.OrderedDict'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'collections.OrderedDict' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'collections.OrderedDict'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'collections.OrderedDict' is not a callable object\n"
        }
    ],
    "music": [
        {
            "acResult": "DADADADUM",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "ENTERTAINER",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "PRELUDE",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "ODE",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "NYAN",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "RINGTONE",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "FUNK",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "BLUES",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "BIRTHDAY",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "WEDDING",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "FUNERAL",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "PUNCHLINE",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "PYTHON",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "BADDY",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "CHASE",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "BA_DING",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "WAWAWAWAA",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "JUMP_UP",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "JUMP_DOWN",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "POWER_UP",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "POWER_DOWN",
            "type": [
                "variable"
            ],
            "documentation": "",
            "version": 0
        },
        {
            "acResult": "set_tempo",
            "type": [
                "function"
            ],
            "documentation": "Sets the approximate tempo for playback.\n\nExample: ``music.set_tempo(bpm=120)``\n\n:param ticks: The number of ticks constituting a beat.\n:param bpm: An integer determining how many beats per minute.\n\nSuggested default values allow the following useful behaviour:\n\n- music.set_tempo() \u2013 reset the tempo to default of ticks = 4, bpm = 120\n- music.set_tempo(ticks=8) \u2013 change the \u201cdefinition\u201d of a beat\n- music.set_tempo(bpm=180) \u2013 just change the tempo\n\nTo work out the length of a tick in milliseconds is very simple arithmetic:\n60000/bpm/ticks_per_beat. For the default values that\u2019s\n60000/120/4 = 125 milliseconds or 1 beat = 500 milliseconds.",
            "version": 0,
            "params": [
                {
                    "name": "ticks",
                    "defaultValue": "120"
                },
                {
                    "name": "bpm",
                    "defaultValue": "4"
                }
            ]
        },
        {
            "acResult": "get_tempo",
            "type": [
                "function"
            ],
            "documentation": "Gets the current tempo as a tuple of integers: ``(ticks, bpm)``.\n\nExample: ``ticks, beats = music.get_tempo()``\n\n:return: The temp as a tuple with two integer values, the ticks then the beats per minute.",
            "version": 0
        },
        {
            "acResult": "play",
            "type": [
                "function"
            ],
            "documentation": "Plays music.\n\nExample: ``music.play(music.NYAN)``\n\n:param music: music specified in `a special notation <https://microbit-micropython.readthedocs.io/en/v2-docs/music.html#musical-notation>`_\n:param pin: the output pin for use with an external speaker (default ``pin0``), ``None`` for no sound.\n:param wait: If ``wait`` is set to ``True``, this function is blocking.\n:param loop: If ``loop`` is set to ``True``, the tune repeats until ``stop`` is called or the blocking call is interrupted.\n\nMany built-in melodies are defined in this module.",
            "version": 0,
            "params": [
                {
                    "name": "music"
                },
                {
                    "name": "pin",
                    "defaultValue": "False"
                },
                {
                    "name": "wait",
                    "defaultValue": "True"
                },
                {
                    "name": "loop"
                }
            ]
        },
        {
            "acResult": "pitch",
            "type": [
                "function"
            ],
            "documentation": "Play a note.\n\nExample: ``music.pitch(185, 1000)``\n\n:param frequency: An integer frequency\n:param duration: A millisecond duration. If negative then sound is continuous until the next call or a call to ``stop``.\n:param pin: Optional output pin (default ``pin0``).\n:param wait: If ``wait`` is set to ``True``, this function is blocking.\n\nFor example, if the frequency is set to 440 and the length to\n1000 then we hear a standard concert A for one second.\n\nYou can only play one pitch on one pin at any one time.",
            "version": 0,
            "params": [
                {
                    "name": "frequency"
                },
                {
                    "name": "duration",
                    "defaultValue": "True"
                },
                {
                    "name": "pin"
                },
                {
                    "name": "wait",
                    "defaultValue": "-1"
                }
            ]
        },
        {
            "acResult": "stop",
            "type": [
                "function"
            ],
            "documentation": "Stops all music playback on the built-in speaker and any pin outputting sound.\n\nExample: ``music.stop()``\n\n:param pin: An optional argument can be provided to specify a pin, e.g. ``music.stop(pin1)``.",
            "version": 0,
            "params": [
                {
                    "name": "pin"
                }
            ]
        },
        {
            "acResult": "reset",
            "type": [
                "function"
            ],
            "documentation": "Resets ticks, bpm, duration and octave to their default values.\n\nExample: ``music.reset()``\n\nValues:\n- ``ticks = 4``\n- ``bpm = 120``\n- ``duration = 4``\n- ``octave = 4``",
            "version": 0
        }
    ],
    "micropython": [
        {
            "acResult": "const",
            "type": [
                "function"
            ],
            "documentation": "Used to declare that the expression is a constant so that the compiler can\noptimise it.\n\nThe use of this function should be as follows::\n\n    from micropython import const\n    CONST_X = const(123)\n    CONST_Y = const(2 * CONST_X + 1)\n\nConstants declared this way are still accessible as global variables from\noutside the module they are declared in. On the other hand, if a constant\nbegins with an underscore then it is hidden, it is not available as a\nglobal variable, and does not take up any memory during execution.\n\n:param expr: A constant expression.",
            "version": 0,
            "params": [
                {
                    "name": "expr"
                }
            ]
        },
        {
            "acResult": "opt_level",
            "type": [
                "function",
                "function"
            ],
            "documentation": "Get the current optimisation level for the compilation of scripts.\n\nExample: ``micropython.opt_level()``\n\nThe optimisation level controls the following compilation features:\n\n- Assertions: at level 0 assertion statements are enabled and compiled\n  into the bytecode; at levels 1 and higher assertions are not compiled.\n\n- Built-in ``__debug__`` variable: at level 0 this variable expands to\n  True; at levels 1 and higher it expands to False.\n\n- Source-code line numbers: at levels 0, 1 and 2 source-code line number\n  are stored along with the bytecode so that exceptions can report the\n  line number they occurred at; at levels 3 and higher line numbers are\n  not stored.\n\n:return: An integer representing the current level.",
            "version": 0
        },
        {
            "acResult": "mem_info",
            "type": [
                "function"
            ],
            "documentation": "Print information about currently used memory.\n\nExample: ``micropython.mem_info()``\n\n:param verbose: If the ``verbose`` argument is given then extra information is printed.",
            "version": 0,
            "params": [
                {
                    "name": "verbose",
                    "defaultValue": "None"
                }
            ]
        },
        {
            "acResult": "qstr_info",
            "type": [
                "function"
            ],
            "documentation": "Print information about currently interned strings.\n\nExample: ``micropython.qstr_info()``\n\n:param verbose: If the ``verbose`` argument is given then extra information is printed.\n\nThe information that is printed is implementation dependent, but currently\nincludes the number of interned strings and the amount of RAM they use.  In\nverbose mode it prints out the names of all RAM-interned strings.",
            "version": 0,
            "params": [
                {
                    "name": "verbose",
                    "defaultValue": "None"
                }
            ]
        },
        {
            "acResult": "stack_use",
            "type": [
                "function"
            ],
            "documentation": "Return an integer representing the current amount of stack that is being\nused.\n\nExample: ``micropython.stack_use()``\n\nThe absolute value of this is not particularly useful, rather it\nshould be used to compute differences in stack usage at different points.\n\n:return: An integer representing current stack use.",
            "version": 0
        },
        {
            "acResult": "heap_lock",
            "type": [
                "function"
            ],
            "documentation": "Lock the heap.\n\nExample: ``micropython.heap_lock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.",
            "version": 0
        },
        {
            "acResult": "heap_unlock",
            "type": [
                "function"
            ],
            "documentation": "Unlock the heap.\n\nExample: ``micropython.heap_unlock()``\n\nWhen locked no memory allocation can occur and a ``MemoryError`` will be\nraised if any heap allocation is attempted.",
            "version": 0
        },
        {
            "acResult": "kbd_intr",
            "type": [
                "function"
            ],
            "documentation": "Set the character that will raise a ``KeyboardInterrupt`` exception.\n\nExample: ``micropython.kbd_intr(-1)``\n\n:param chr: Character code to raise the interrupt or -1 to disable capture of Ctrl-C.\n\nBy default this is set to 3 during script execution, corresponding to Ctrl-C.\nPassing -1 to this function will disable capture of Ctrl-C, and passing 3\nwill restore it.\n\nThis function can be used to prevent the capturing of Ctrl-C on the\nincoming stream of characters that is usually used for the REPL, in case\nthat stream is used for other purposes.",
            "version": 0,
            "params": [
                {
                    "name": "chr"
                }
            ]
        }
    ],
    "array": [
        {
            "acResult": "array",
            "type": [
                "type",
                "function"
            ],
            "documentation": "Return a new array whose items are restricted by typecode, and\ninitialized from the optional initializer value, which must be a list,\nstring or iterable over elements of the appropriate type.\n\nArrays represent basic values and behave very much like lists, except\nthe type of objects stored in them is constrained. The type is specified\nat object creation time by using a type code, which is a single character.\nThe following type codes are defined:\n\n    Type code   C Type             Minimum size in bytes\n    'b'         signed integer     1\n    'B'         unsigned integer   1\n    'u'         Unicode character  2 (see note)\n    'h'         signed integer     2\n    'H'         unsigned integer   2\n    'i'         signed integer     2\n    'I'         unsigned integer   2\n    'l'         signed integer     4\n    'L'         unsigned integer   4\n    'q'         signed integer     8 (see note)\n    'Q'         unsigned integer   8 (see note)\n    'f'         floating point     4\n    'd'         floating point     8\n\nNOTE: The 'u' typecode corresponds to Python's unicode character. On\nnarrow builds this is 2-bytes on wide builds this is 4-bytes.\n\nNOTE: The 'q' and 'Q' type codes are only available if the platform\nC compiler used to build Python supports 'long long', or, on Windows,\n'__int64'.\n\nMethods:\n\nappend() -- append a new item to the end of the array\nbuffer_info() -- return information giving the current memory info\nbyteswap() -- byteswap all the items of the array\ncount() -- return number of occurrences of an object\nextend() -- extend array by appending multiple elements from an iterable\nfromfile() -- read items from a file object\nfromlist() -- append items from the list\nfrombytes() -- append items from the string\nindex() -- return index of first occurrence of an object\ninsert() -- insert a new item into the array at a provided position\npop() -- remove and return item (default last)\nremove() -- remove first occurrence of an object\nreverse() -- reverse the order of the items in the array\ntofile() -- write all items to a file object\ntolist() -- return the array converted to an ordinary list\ntobytes() -- return the array converted to a string\n\nAttributes:\n\ntypecode -- the typecode character used to create the array\nitemsize -- the length in bytes of one array item",
            "version": 0,
            "errors": "Fellback through everything and parse_arguments failed on Python Library Documentation: class array in array\n\na\bar\brr\bra\bay\by.\b.a\bar\brr\bra\bay\by = class array(builtins.object)\n |  array(typecode [, initializer]) -> array\n |  \n |  Return a new array whose items are restricted by typecode, and\n |  initialized from the optional initializer value, which must be a list,\n |  string or iterable over elements of the appropriate type.\n |  \n |  Arrays represent basic values and behave very much like lists, except\n |  the type of objects stored in them is constrained. The type is specified\n |  at object creation time by using a type code, which is a single character.\n |  The following type codes are defined:\n |  \n |      Type code   C Type             Minimum size in bytes\n |      'b'         signed integer     1\n |      'B'         unsigned integer   1\n |      'u'         Unicode character  2 (see note)\n |      'h'         signed integer     2\n |      'H'         unsigned integer   2\n |      'i'         signed integer     2\n |      'I'         unsigned integer   2\n |      'l'         signed integer     4\n |      'L'         unsigned integer   4\n |      'q'         signed integer     8 (see note)\n |      'Q'         unsigned integer   8 (see note)\n |      'f'         floating point     4\n |      'd'         floating point     8\n |  \n |  NOTE: The 'u' typecode corresponds to Python's unicode character. On\n |  narrow builds this is 2-bytes on wide builds this is 4-bytes.\n |  \n |  NOTE: The 'q' and 'Q' type codes are only available if the platform\n |  C compiler used to build Python supports 'long long', or, on Windows,\n |  '__int64'.\n |  \n |  Methods:\n |  \n |  append() -- append a new item to the end of the array\n |  buffer_info() -- return information giving the current memory info\n |  byteswap() -- byteswap all the items of the array\n |  count() -- return number of occurrences of an object\n |  extend() -- extend array by appending multiple elements from an iterable\n |  fromfile() -- read items from a file object\n |  fromlist() -- append items from the list\n |  frombytes() -- append items from the string\n |  index() -- return index of first occurrence of an object\n |  insert() -- insert a new item into the array at a provided position\n |  pop() -- remove and return item (default last)\n |  remove() -- remove first occurrence of an object\n |  reverse() -- reverse the order of the items in the array\n |  tofile() -- write all items to a file object\n |  tolist() -- return the array converted to an ordinary list\n |  tobytes() -- return the array converted to a string\n |  \n |  Attributes:\n |  \n |  typecode -- the typecode character used to create the array\n |  itemsize -- the length in bytes of one array item\n |  \n |  Methods defined here:\n |  \n |  _\b__\b_a\bad\bdd\bd_\b__\b_(self, value, /)\n |      Return self+value.\n |  \n |  _\b__\b_c\bco\bon\bnt\bta\bai\bin\bns\bs_\b__\b_(self, key, /)\n |      Return key in self.\n |  \n |  _\b__\b_c\bco\bop\bpy\by_\b__\b_(self, /)\n |      Return a copy of the array.\n |  \n |  _\b__\b_d\bde\bee\bep\bpc\bco\bop\bpy\by_\b__\b_(self, unused, /)\n |      Return a copy of the array.\n |  \n |  _\b__\b_d\bde\bel\bli\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Delete self[key].\n |  \n |  _\b__\b_e\beq\bq_\b__\b_(self, value, /)\n |      Return self==value.\n |  \n |  _\b__\b_g\bge\be_\b__\b_(self, value, /)\n |      Return self>=value.\n |  \n |  _\b__\b_g\bge\bet\bta\bat\btt\btr\bri\bib\bbu\but\bte\be_\b__\b_(self, name, /)\n |      Return getattr(self, name).\n |  \n |  _\b__\b_g\bge\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, /)\n |      Return self[key].\n |  \n |  _\b__\b_g\bgt\bt_\b__\b_(self, value, /)\n |      Return self>value.\n |  \n |  _\b__\b_i\bia\bad\bdd\bd_\b__\b_(self, value, /)\n |      Implement self+=value.\n |  \n |  _\b__\b_i\bim\bmu\bul\bl_\b__\b_(self, value, /)\n |      Implement self*=value.\n |  \n |  _\b__\b_i\bit\bte\ber\br_\b__\b_(self, /)\n |      Implement iter(self).\n |  \n |  _\b__\b_l\ble\be_\b__\b_(self, value, /)\n |      Return self<=value.\n |  \n |  _\b__\b_l\ble\ben\bn_\b__\b_(self, /)\n |      Return len(self).\n |  \n |  _\b__\b_l\blt\bt_\b__\b_(self, value, /)\n |      Return self<value.\n |  \n |  _\b__\b_m\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return self*value.\n |  \n |  _\b__\b_n\bne\be_\b__\b_(self, value, /)\n |      Return self!=value.\n |  \n |  _\b__\b_r\bre\bed\bdu\buc\bce\be_\b_e\bex\bx_\b__\b_(self, value, /)\n |      Return state information for pickling.\n |  \n |  _\b__\b_r\bre\bep\bpr\br_\b__\b_(self, /)\n |      Return repr(self).\n |  \n |  _\b__\b_r\brm\bmu\bul\bl_\b__\b_(self, value, /)\n |      Return value*self.\n |  \n |  _\b__\b_s\bse\bet\bti\bit\bte\bem\bm_\b__\b_(self, key, value, /)\n |      Set self[key] to value.\n |  \n |  _\b__\b_s\bsi\biz\bze\beo\bof\bf_\b__\b_(self, /)\n |      Size of the array in memory, in bytes.\n |  \n |  a\bap\bpp\bpe\ben\bnd\bd(self, v, /)\n |      Append new value v to the end of the array.\n |  \n |  b\bbu\buf\bff\bfe\ber\br_\b_i\bin\bnf\bfo\bo(self, /)\n |      Return a tuple (address, length) giving the current memory address and the length in items of the buffer used to hold array's contents.\n |      \n |      The length should be multiplied by the itemsize attribute to calculate\n |      the buffer length in bytes.\n |  \n |  b\bby\byt\bte\bes\bsw\bwa\bap\bp(self, /)\n |      Byteswap all items of the array.\n |      \n |      If the items in the array are not 1, 2, 4, or 8 bytes in size, RuntimeError is\n |      raised.\n |  \n |  c\bco\bou\bun\bnt\bt(self, v, /)\n |      Return number of occurrences of v in the array.\n |  \n |  e\bex\bxt\bte\ben\bnd\bd(self, bb, /)\n |      Append items to the end of the array.\n |  \n |  f\bfr\bro\bom\bmb\bby\byt\bte\bes\bs(self, buffer, /)\n |      Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method).\n |  \n |  f\bfr\bro\bom\bmf\bfi\bil\ble\be(self, f, n, /)\n |      Read n objects from the file object f and append them to the end of the array.\n |  \n |  f\bfr\bro\bom\bml\bli\bis\bst\bt(self, list, /)\n |      Append items to array from list.\n |  \n |  f\bfr\bro\bom\bms\bst\btr\bri\bin\bng\bg(self, buffer, /)\n |      Appends items from the string, interpreting it as an array of machine values, as if it had been read from a file using the fromfile() method).\n |      \n |      This method is deprecated. Use frombytes instead.\n |  \n |  f\bfr\bro\bom\bmu\bun\bni\bic\bco\bod\bde\be(self, ustr, /)\n |      Extends this array with data from the unicode string ustr.\n |      \n |      The array must be a unicode type array; otherwise a ValueError is raised.\n |      Use array.frombytes(ustr.encode(...)) to append Unicode data to an array of\n |      some other type.\n |  \n |  i\bin\bnd\bde\bex\bx(self, v, /)\n |      Return index of first occurrence of v in the array.\n |  \n |  i\bin\bns\bse\ber\brt\bt(self, i, v, /)\n |      Insert a new item v into the array before position i.\n |  \n |  p\bpo\bop\bp(self, i=-1, /)\n |      Return the i-th element and delete it from the array.\n |      \n |      i defaults to -1.\n |  \n |  r\bre\bem\bmo\bov\bve\be(self, v, /)\n |      Remove the first occurrence of v in the array.\n |  \n |  r\bre\bev\bve\ber\brs\bse\be(self, /)\n |      Reverse the order of the items in the array.\n |  \n |  t\bto\bob\bby\byt\bte\bes\bs(self, /)\n |      Convert the array to an array of machine values and return the bytes representation.\n |  \n |  t\bto\bof\bfi\bil\ble\be(self, f, /)\n |      Write all items (as machine values) to the file object f.\n |  \n |  t\bto\bol\bli\bis\bst\bt(self, /)\n |      Convert array to an ordinary list with the same items.\n |  \n |  t\bto\bos\bst\btr\bri\bin\bng\bg(self, /)\n |      Convert the array to an array of machine values and return the bytes representation.\n |      \n |      This method is deprecated. Use tobytes instead.\n |  \n |  t\bto\bou\bun\bni\bic\bco\bod\bde\be(self, /)\n |      Extends this array with data from the unicode string ustr.\n |      \n |      Convert the array to a unicode string.  The array must be a unicode type array;\n |      otherwise a ValueError is raised.  Use array.tobytes().decode() to obtain a\n |      unicode string from an array of some other type.\n |  \n |  ----------------------------------------------------------------------\n |  Static methods defined here:\n |  \n |  _\b__\b_n\bne\bew\bw_\b__\b_(*args, **kwargs) from builtins.type\n |      Create and return a new object.  See help(type) for accurate signature.\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  i\bit\bte\bem\bms\bsi\biz\bze\be\n |      the size, in bytes, of one array item\n |  \n |  t\bty\byp\bpe\bec\bco\bod\bde\be\n |      the typecode character used to create the array\n |  \n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |  \n |  _\b__\b_h\bha\bas\bsh\bh_\b__\b_ = None\n earlier errs: unsupported callableTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'array.array'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n'array.array' is not a callable objectTraceback (most recent call last):\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1135, in getfullargspec\n    sig = _signature_from_callable(func,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2384, in _signature_from_callable\n    raise ValueError(\nValueError: no signature found for builtin type <class 'array.array'>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 227, in <module>\n    cls, argspec = get_class_and_func(item['acResult'], imp_mod)\n  File \"scripts/add-docs-from-python.py\", line 139, in get_class_and_func\n    return None, inspect.getfullargspec(attrgetter(ac_result)(imp_mod))  # fallback\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 1144, in getfullargspec\n    raise TypeError('unsupported callable') from ex\nTypeError: unsupported callable\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"scripts/add-docs-from-python.py\", line 241, in <module>\n    item['signature'] = convert_inspect_signature_to_signature(inspect.signature(mod + \".\" + item['acResult']))\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 3105, in signature\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped)\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2854, in from_callable\n    return _signature_from_callable(obj, sigcls=cls,\n  File \"/opt/homebrew/Cellar/python@3.8/3.8.19/Frameworks/Python.framework/Versions/3.8/lib/python3.8/inspect.py\", line 2228, in _signature_from_callable\n    raise TypeError('{!r} is not a callable object'.format(obj))\nTypeError: 'array.array' is not a callable object\n"
        }
    ],
    "antigravity": [],
    "power": [
        {
            "acResult": "off",
            "type": [
                "function"
            ],
            "documentation": "Power down the board to the lowest possible power mode.\n\nExample: ``power.off()``\n\nThis is the equivalent to pressing the reset button for a few seconds,\nto set the board in \"Off mode\".\n\nThe micro:bit will only wake up if the reset button is pressed or,\nif on battery power, when a USB cable is connected.\n\nWhen the board wakes up it will start for a reset state, so your program\nwill start running from the beginning.",
            "version": 0
        },
        {
            "acResult": "deep_sleep",
            "type": [
                "function"
            ],
            "documentation": "Set the micro:bit into a low power mode where it can wake up and continue operation.\n\nExample: ``power.deep_sleep(wake_on=(button_a, button_b))``\n\nThe program state is preserved and when it wakes up it will resume\noperation where it left off.\n\nDeep Sleep mode will consume more battery power than Off mode.\n\nThe wake up sources are configured via arguments.\n\nThe board will always wake up when receiving UART data, when the reset\nbutton is pressed (which resets the board) or, in battery power,\nwhen the USB cable is inserted.\n\nWhen the ``run_every`` parameter is set to ``True`` (the default), any\nfunction scheduled with ``run_every`` will momentarily wake up the board\nto run and when it finishes it will go back to sleep.\n\n:param ms: A time in milliseconds to wait before it wakes up.\n:param wake_on: A single instance or a tuple of pins and/or buttons to wake up the board, e.g. ``deep_sleep(wake_on=button_a)`` or ``deep_sleep(wake_on=(pin0, pin2, button_b))``.\n:param run_every: A boolean to configure if the functions scheduled with ``microbit.run_every`` will continue to run while it sleeps.",
            "version": 0,
            "params": [
                {
                    "name": "ms",
                    "defaultValue": "True"
                },
                {
                    "name": "wake_on",
                    "defaultValue": "None"
                },
                {
                    "name": "run_every",
                    "defaultValue": "None"
                }
            ]
        }
    ],
    "ucollections": [],
    "neopixel": [
        {
            "acResult": "NeoPixel",
            "type": [
                "type",
                "function"
            ],
            "documentation": "",
            "version": 0
        }
    ]
}